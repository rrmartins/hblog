<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Ruby 1.8 on Rodrigo Martins </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://rodij.me/categories/ruby-1/index.8/</link>
    <language>en-us</language>
    
    <copyright>I&#39;m a Catholic Christian, software developer, Passionate about life, codes, questions, theories and theorems. :)</copyright>
    <updated>Sat, 14 Jul 2012 00:00:00 UTC</updated>
    
    <item>
      <title>iteradores numericos</title>
      <link>http://rodij.me/post/2012/07/14/iteradores-numericos/</link>
      <pubDate>Sat, 14 Jul 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/07/14/iteradores-numericos/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de `Iteradores Numéricos`... Estranho para alguns, mas, veremos que é simples!&lt;/p&gt;

&lt;h1&gt;Iteradores Numéricos&lt;/h1&gt;

&lt;p&gt;O núcleo do &lt;code&gt;Ruby API&lt;/code&gt; fornece um número de iteradores padrão. Os métodos de loops do Kernel se comporta como um
loop infinito, executando seu bloco associado repetidamente até que o bloco executa um &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, ou outra
declaração que sai do laço.&lt;/p&gt;

&lt;p&gt;A classe &lt;code&gt;Integer&lt;/code&gt; define três iteradores usados. O método &lt;code&gt;upto&lt;/code&gt; chama seu bloco associado uma vez para cada número
inteiro entre o número inteiro no qual ele é invocado e o número inteiro que é passado como um argumento.
Por exemplo:&lt;/p&gt;

&lt;p&gt;``` ruby upto
4.upto(6){|x| print x} # =&amp;gt; prints &amp;ldquo;456&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Como você pode ver, `upto` intera cada número inteiro para o bloco associado, e inclui tanto o ponto de partida e o
ponto final na iteração. Em geral, `n.upto(m)` é executado o bloco `m-n +1` vezes.

O método `downto` é como `upto` mas itera a partir de um maior número para um número menor.

Quando o método `Integer.times` é chamado no `n` inteiro, invoque o seu bloco de `n vezes`, passando os valores de
`0 a n-1` em iterações sucessivas. Por exemplo:

``` ruby times
3.times {|x| print x }    # =&amp;gt; prints &amp;quot;012&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Em geral, é &lt;code&gt;n.times&lt;/code&gt; equivalente a &lt;code&gt;0.upto(n-1)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se você quer fazer uma iteração numérica usando um ponto flutuante de números, você pode usar o método &lt;code&gt;step&lt;/code&gt; mais
complexo definido pela classe numérica. O iterador a seguir, por exemplo, começa a 0 e itera em passos de 0.1 até
atingir &lt;code&gt;Math::PI&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby metodo step
0.step(Math::PI, 0.1){|x| puts Math.sin(x)}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Até a proxima!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>unless number ruby 1 dot 9</title>
      <link>http://rodij.me/post/2012/07/05/unless-number-ruby-1-dot-9/</link>
      <pubDate>Thu, 05 Jul 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/07/05/unless-number-ruby-1-dot-9/</guid>
      <description>

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de `unless`... Estranho para alguns, mas, veremos que é simples!&lt;/p&gt;

&lt;h1&gt;Unless&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;unless&lt;/code&gt;, como uma declaração ou um modificador, é o oposto do &lt;code&gt;case&lt;/code&gt;: ele executa o código apenas se uma expressão
associada é avaliada como &lt;code&gt;false&lt;/code&gt; ou &lt;code&gt;nil&lt;/code&gt;. Sua sintaxe é como &lt;code&gt;if&lt;/code&gt;, exceto que as cláusulas &lt;code&gt;elsif&lt;/code&gt;, que não são
permitidas:&lt;/p&gt;

&lt;p&gt;``` ruby Declaração unless&lt;/p&gt;

&lt;h1 id=&#34;uma-maneira-declaração-unless&#34;&gt;Uma maneira, declaração unless&lt;/h1&gt;

&lt;p&gt;unless condition
  code
end&lt;/p&gt;

&lt;h1 id=&#34;duas-vias-da-declaração-unless&#34;&gt;Duas vias da declaração unless&lt;/h1&gt;

&lt;p&gt;unless condition
  code
else
  code
end&lt;/p&gt;

&lt;h1 id=&#34;modificador-unless&#34;&gt;modificador unless&lt;/h1&gt;

&lt;p&gt;code unless condition&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
A declaração `unless`, como a declaração `if`, exige que a condição e o código são separados por uma mudança de linha,
uma vírgula, ou a palavra-chave `then`. Também como `if`, as declarações `unless` são expressões e retornam o valor do
código que são executados, ou `nil` se executar nada:

``` ruby Declaração unless
# Chama o método to_s sobre o objeto, a menos que o objeto &#39;o&#39; for nulo
s = unless o.nil?                        # Nova linha de separação
  o.to_s
end

s = unless o.nil? then o.to_s end        # separador então
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para uma única linha condicionais como esta, a forma do modificador &lt;code&gt;unless&lt;/code&gt; é geralmente mais clara:&lt;/p&gt;

&lt;p&gt;``` ruby Unless
s = o.to_s unless o.nil?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Ruby não tem nenhum equivalente da cláusula `elsif` para a condicional `unless`. Você ainda pode escrever um multiway da instrução `unless`, no entanto, se você está disposto a ser um pouco mais detalhado:

``` ruby unless
unless x == 0
  puts &amp;quot;x is not 0&amp;quot;
else
  unless y == 0
    puts &amp;quot;y is not 0&amp;quot;
  else
    unless z == 0
      puts &amp;quot;z is not 0&amp;quot;
    else
      puts &amp;quot;all are 0&amp;quot;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É isso ai amigos!&lt;/p&gt;

&lt;p&gt;Para todos aqueles que não sabiam ao certo o que seria o &lt;code&gt;unless&lt;/code&gt;, e que tipo de monstro é isso..&lt;/p&gt;

&lt;p&gt;Esta ai..&lt;/p&gt;

&lt;p&gt;Até a proxima!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>demonstracoes e estruturas de controle</title>
      <link>http://rodij.me/post/2012/06/18/demonstracoes-e-estruturas-de-controle/</link>
      <pubDate>Mon, 18 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/06/18/demonstracoes-e-estruturas-de-controle/</guid>
      <description>

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Demonstrações e estruturas de controle&lt;/p&gt;

&lt;h1&gt;Demonstrações e estruturas de controle&lt;/h1&gt;

&lt;p&gt;Considere o programa Ruby seguinte. Acrescenta dois números passados ​​para na linha de comando e imprime a soma:&lt;/p&gt;

&lt;p&gt;``` ruby Programa Simples
x = ARGV[0].to_f # Converter primeiro argumento para um número
y = ARGV[1].to_f # Converter segundo argumento para um número
soma = x + y # Adicione os argumentos
puts soma # Imprimir a soma&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Este é um programa simples que consiste essencialmente em invocar variável de atribuição e método. O que o torna
particularmente simples é sua execução puramente seqüencial. As quatro linhas de código são executadas uma após a outra
sem ramificação ou repetição. É um programa raro que pode ser tão simples.


&amp;lt;h3&amp;gt;Condicionais&amp;lt;/h3&amp;gt;

A estrutura de controle mais comum, em qualquer linguagem de programação, é a condicional. Esta é uma forma de dizer ao
computador para condicionalmente executar alguns códigos: para executar ele, só se alguma condição for satisfeita.
A condição é uma expressão, se for avaliada como qualquer valor diferente de falso ou nulo, então a condição é satisfeita.

Ruby tem um vocabulário rico para expressar condicionais. Algumas sintaxes são descritas abaixo. Ao escrever código Ruby,
você pode escolher o que parece mais elegante para a tarefa.


&amp;lt;h5&amp;gt;if&amp;lt;/h5&amp;gt;

Ele é a mais simples das condicionais. Em sua forma mais simples, parece que isso:

``` ruby Condicional IF
if expression
  code
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código entre &lt;code&gt;if&lt;/code&gt; e &lt;code&gt;end&lt;/code&gt;é executado se (e somente se) o &lt;code&gt;expression&lt;/code&gt; é avaliada como algo diferente que &lt;code&gt;falso&lt;/code&gt; ou
&lt;code&gt;nulo&lt;/code&gt;. O código deve ser separado a partir da expressão com uma nova linha ou ponto e vírgula ou a palavra-chave, em
seguida. Aqui estão duas maneiras de escrever a mesma condicional &lt;code&gt;if&lt;/code&gt; de forma simples:&lt;/p&gt;

&lt;p&gt;```ruby Condicional IF&lt;/p&gt;

&lt;h1 id=&#34;se-x-é-menor-que-10-incrementá-lo&#34;&gt;Se x é menor que 10, incrementá-lo&lt;/h1&gt;

&lt;p&gt;if x &amp;lt; 10 # nova linha de separação
  x + = 1
end
if x &amp;lt; 10 then x += 1 end # the separato&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Você também pode usar `then` como o símbolo de separação, e segui-lo com uma nova linha. Isso torna o seu código robusto.

``` ruby Condicional IF
if x &amp;lt; 10 then
  x + = 1
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os programadores que estão acostumados a C, ou linguagens cuja sintaxe é derivada de C, deve observar duas coisas
importantes sobre if no Ruby:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Parênteses não é necessário (e normalmente não utilizado) em torno da expressão condicional. O ponto e vírgula, quebra
de linha, ou então palavra-chave serve para delimitar a expressão.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A palavra-chave &lt;code&gt;end&lt;/code&gt; é exigida, mesmo quando o código a ser executado condicionalmente consiste de uma única instrução.
A forma modificador do &lt;code&gt;if&lt;/code&gt;, descrito abaixo, fornece uma maneira para gravar condicionais simples sem a palavra-chave &lt;code&gt;end&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;else&lt;/h5&gt;

&lt;p&gt;Uma declaração &lt;code&gt;if&lt;/code&gt; pode incluir uma cláusula &lt;code&gt;else&lt;/code&gt; para especificar o código para ser executado se a condição não é
&lt;code&gt;true&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` ruby Condicional else
if expression
  code
else
  code
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
O código entre `if` e `else` é executado se `expression` é avaliada como qualquer outra coisa que `false` ou `nil`. Caso
contrário (se expression é `false` ou `nil`), o código entre o `else` e o `end` é executado. Como na forma simples
de `if`, na expressão deve ser separado do código que o segue por uma nova linha, um ponto e vírgula, ou a palavra-chave `then`. As palavras-chave `else` e `end`, totalmente delimitam o segundo pedaço de código, e sem novas linhas ou
delimitadores adicionais são exigido.

Aqui é um exemplo de um condicional que inclui uma cláusula `else`:

``` ruby Condicional if - else
if dados # Se o array existe
  dados &amp;lt;&amp;lt; x # em seguida, acrescentar um valor a ela.
else # Caso contrário ...
  data = [x] # criar uma nova matriz que contém o valor.
end # Este é o fim do condicional
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;elsif&lt;/h5&gt;

&lt;p&gt;Se você quiser testar mais de uma condição dentro de uma condicional, você pode adicionar um ou mais cláusulas &lt;code&gt;elsif&lt;/code&gt;
entre um &lt;code&gt;if&lt;/code&gt; e um &lt;code&gt;else&lt;/code&gt;. &lt;code&gt;elsif&lt;/code&gt; é uma forma abreviada de &lt;code&gt;else if&lt;/code&gt;. Note que há apenas um &lt;code&gt;else&lt;/code&gt; em &lt;code&gt;elsif&lt;/code&gt;. A condicional &lt;code&gt;elsif&lt;/code&gt; usando parecido com este:&lt;/p&gt;

&lt;p&gt;```ruby Expressão elsif
if expression1
  code1
elsif expression2
  code2
      .
      .
      .
elsif expressionN
  codeN
else
  code
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Se `expression1` for avaliado não sendo `false` ou `nil`, então `code1` é executado. Caso contrário, `expression2` é
avaliada. Se for outra coisa senão `false` ou `nil`, então code2 é executado. Este processo continua até que uma expressão
é avaliada como algo diferente de `false` ou `nil`, ou até que todas as cláusulas `elsif` foram testadas. Se a expressão
associada com a última cláusula `elsif` for `false` ou `nil`, e da cláusula `elsif` é seguido por uma cláusula `else`, em
seguida, o código entre `else` e no `end` é executado. Se nenhuma cláusula mais está presente, em seguida, nenhum código é
executado.

`elsif` é como se: a expressão deve ser separada do código por uma nova linha, uma vírgula ou uma palavra-chave, em seguida
. Aqui é um exemplo de uma multi condicional usando `elsif`:

```ruby Condicional elsif
if x == 1
  name = &amp;quot;um&amp;quot;
elsif x == 2
  name = &amp;quot;dois&amp;quot;
elsif x == 3 then name = &amp;quot;três&amp;quot;
elsif x == 4; name = &amp;quot;quatro&amp;quot;
else
  name = &amp;quot;muitos&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Valor de retorno&lt;/h5&gt;

&lt;p&gt;Na maioria das linguagens, a condicional &lt;code&gt;if&lt;/code&gt; é uma afirmação. Em Ruby, no entanto, tudo é uma expressão, mesmo as
estruturas de controle que são comumente chamadas de declarações. O valor &lt;code&gt;return&lt;/code&gt; de uma &amp;ldquo;declaração&amp;rdquo; &lt;code&gt;if&lt;/code&gt;, é o valor da
última expressão no código que foi executado, ou &lt;code&gt;nil&lt;/code&gt; se nenhum bloco de código foi executado.&lt;/p&gt;

&lt;p&gt;O fato de que, as declarações &lt;code&gt;if&lt;/code&gt; devolvem um valor significa que, por exemplo, a muilti condicional mostrado
anteriormente pode ser elegantemente reescrito como este abaixo:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Valor de Retorno
name = if x == 1 then &amp;quot;um&amp;quot;
       elsif x == 2 then &amp;quot;dois&amp;quot;
       elsif x == 3 then &amp;quot;três&amp;quot;
       elsif x == 4 then &amp;quot;quatro&amp;quot;
       else &amp;quot;muitos&amp;quot;
       end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;É isso aí amigos..&lt;/p&gt;

&lt;p&gt;Bons estudos e até a proxima! :D&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>atribuicao paralela number ruby</title>
      <link>http://rodij.me/post/2012/06/11/atribuicao-paralela-number-ruby/</link>
      <pubDate>Mon, 11 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/06/11/atribuicao-paralela-number-ruby/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Atribuições Paralelas&lt;/p&gt;

&lt;h1&gt;Atribuições Paralelas&lt;/h1&gt;

&lt;p&gt;Atribuição paralela é qualquer atribuição de expressão que tem mais do que um &lt;code&gt;lvalue&lt;/code&gt;, mais do que um &lt;code&gt;rvalue&lt;/code&gt;, ou ambos. Múltiplos &lt;code&gt;lvalues&lt;/code&gt; e ​​múltiplos &lt;code&gt;rvalues&lt;/code&gt; são separados uns dos outros com uma vírgula. &lt;code&gt;lvalues&lt;/code&gt; e &lt;code&gt;rvalues&lt;/code&gt; ​​pode ser prefixado com &lt;code&gt;*&lt;/code&gt;, que às vezes é chamado de operador &lt;code&gt;splat&lt;/code&gt;, embora não seja um verdadeiro operador. O significado de &lt;code&gt;*&lt;/code&gt; é explicado mais adiante neste post.&lt;/p&gt;

&lt;p&gt;Expressões de atribuição mais paralelas são simples, e é óbvio que eles significam. Existem alguns casos complicados, no entanto, e os subtitulos seguintes explicam todas as possibilidades.&lt;/p&gt;

&lt;h5&gt;Mesmo número de lvalues ​​e rvalues&lt;/h5&gt;

&lt;p&gt;Atribuição paralela é a sua forma mais simples quando não são os mesmos número de &lt;code&gt;lvalues&lt;/code&gt; ​​e &lt;code&gt;rvalues&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição de Mesmo número
x, y, z = 1, 2, 3 # x = 1; y = 2; z = 3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Neste caso, o primeiro `rvalue` é atribuído ao primeiro `lvalue`; o segundo `rvalue` é atribuído ao segundo `lvalue`, e assim por diante.

Estas atribuições são efetivamente executadas em paralelo, não seqüencialmente. Por exemplo, as seguintes duas linhas não são as mesmas:

``` ruby Atribuição
x, y = y, x # Paralela: trocar o valor de duas variáveis
x = y; y = x # seqüencial: ambas as variáveis ​​têm o mesmo valor
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Um lvalue, ​​múltiplos rvalues&lt;/h5&gt;

&lt;p&gt;Quando há um único &lt;code&gt;lvalue&lt;/code&gt; e mais do que um &lt;code&gt;rvalue&lt;/code&gt;, Ruby cria um &lt;code&gt;array&lt;/code&gt; para armazenar os &lt;code&gt;rvalues&lt;/code&gt; ​​e atribui esse &lt;code&gt;array&lt;/code&gt; para o &lt;code&gt;lvalue&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` ruby Um lvalue e Múltiplos rvalues
x = 1, 2, 3 # x = [1,2,3]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Você pode colocar um `*` antes do lvalue sem alterar o significado ou o valor de retorno desta atribuição.

Se você quiser impedir que os ​múltiplos `rvalues` de serem combinados em um único `array`, siga o `lvalue` com uma vírgula. Mesmo sem um lvalue depois da vírgula, isto torna que o Ruby se comporte como se há ​​múltiplos lvalues:

``` ruby Atribuições
x, = 1, 2, 3 # x = 1; outros valores são descartados
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;M​últiplos lvalues, array único de rvalue&lt;/h5&gt;

&lt;p&gt;Quando existem múltiplos &lt;code&gt;lvalues​&lt;/code&gt; e apenas um único &lt;code&gt;rvalue&lt;/code&gt;, Ruby tenta expandir o rvalue em uma &lt;code&gt;lista&lt;/code&gt; de valores a atribuir. Se o &lt;code&gt;rvalue&lt;/code&gt; é um &lt;code&gt;array&lt;/code&gt;, Ruby expande o &lt;code&gt;array&lt;/code&gt; para que cada elemento torna-se seu próprio &lt;code&gt;rvalue&lt;/code&gt;. Se o &lt;code&gt;rvalue&lt;/code&gt; não é um &lt;code&gt;array&lt;/code&gt;, mas implementa um método &lt;code&gt;to_ary&lt;/code&gt;, Ruby invoca esse método e, em seguida, se expande o &lt;code&gt;array&lt;/code&gt; no retorno:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
x, y, z = [1, 2, 3] # mesmo que x, y, z = 1,2,3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
A atribuição paralela foi transformado de modo que há ​​múltiplos `lvalues` e zero (se expandida o `array` estando `empty`) ou mais `rvalues`. Se o número de `lvalues` ​​e `rvalues` ​​são os mesmos, então a atribuição ocorre conforme descrito anteriormente, Mesmo número de lvalues ​​e rvalues`. Se os números são diferentes, então a atribuição ocorre como descrito a seguir em `Diferentes números de lvalues ​​e rvalues`.

Podemos usar o truque de fuga por vírgula descrito acima para transformar uma sessão ordinária não paralela em uma atribuição que automaticamente descompacta um `array` à direita:

``` ruby Atribuição
x = [1,2] # x torna-se [1,2]: isso não é atribuição paralela
x, = [1,2] # x torna-se 1: da vírgula torna paralelo
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Diferentes números de lvalues ​​e rvalues&lt;/h5&gt;

&lt;p&gt;Se houver &lt;code&gt;lvalues&lt;/code&gt; mais do que ​​&lt;code&gt;rvalues&lt;/code&gt;, e nenhum operador &lt;code&gt;splat&lt;/code&gt; é envolvido, em seguida, o primeiro &lt;code&gt;rvalue&lt;/code&gt; é atribuído ao primeiro &lt;code&gt;lvalue&lt;/code&gt;, o segundo &lt;code&gt;rvalue&lt;/code&gt; é atribuído ao segundo &lt;code&gt;lvalue&lt;/code&gt;, e assim por diante, até todos os &lt;code&gt;rvalues&lt;/code&gt; ​​forem atribuídos. Em seguida, cada um dos restantes &lt;code&gt;lvalues&lt;/code&gt; ​​é atribuído nil, substituindo qualquer valor existente para que &lt;code&gt;lvalue&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
x, y, z = 1, 2 # x = 1; y = 2; z = nil&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Se houver `rvalues` mais do que ​`​lvalues`, e nenhum operador `splat` é envolvido, em seguida, os `rvalues` ​são atribuídos em ordem a cada um dos `lvalues`, e os restantes `rvalues` são descartados :

```ruby Atribuição
x, y = 1, 2, 3 # x = 1; y = 2, 3 não é atribuído
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;O operador splat&lt;/h5&gt;

&lt;p&gt;Quando um &lt;code&gt;rvalue&lt;/code&gt; é precedido por um asterisco(&lt;code&gt;*&lt;/code&gt;), isso significa que o referido valor é um &lt;code&gt;array&lt;/code&gt; e que seus elementos devem ser cada um &lt;code&gt;rvalues&lt;/code&gt;. Os elementos do &lt;code&gt;array&lt;/code&gt; substituem o &lt;code&gt;array&lt;/code&gt; na lista original do &lt;code&gt;rvalue&lt;/code&gt;, e a atribuição procede como descrito abaixo:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
x, y, z = 1, * [2,3] # mesmo que x, y, z = 1,2,3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
No Ruby 1.8, um splat só pode aparecer antes do último `rvalue` em uma atribuição. No Ruby 1.9, a lista de `rvalues` ​​em uma atribuição paralela pode ter qualquer número de `splats`, e eles podem aparecer em qualquer posição na lista. Não é legal, porém, em qualquer versão da linguagem, para tentar um &amp;quot;splat double&amp;quot; em uma lista aninhada:

```ruby Erro de Atribuição
x,y = **[[1,2]]   # SyntaxError!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os &lt;code&gt;rvalues&lt;/code&gt; com i​ntervalo de &lt;code&gt;arrays&lt;/code&gt; e de &lt;code&gt;hash&lt;/code&gt; pode ser &lt;code&gt;splatted&lt;/code&gt;. Em geral, qualquer &lt;code&gt;rvalue&lt;/code&gt; que define um método &lt;code&gt;to_a&lt;/code&gt; pode ser prefixado com um &lt;code&gt;splat&lt;/code&gt;. Qualquer objeto &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Enumerable.html&#34;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt;, incluindo enumeradores pode ser &lt;code&gt;splatted&lt;/code&gt;, por exemplo. Quando um &lt;code&gt;splat&lt;/code&gt; é aplicado a um objecto que não define um método &lt;code&gt;to_a&lt;/code&gt;, nenhuma expansão é realizada e o &lt;code&gt;splat&lt;/code&gt; avaliado como o próprio objeto.&lt;/p&gt;

&lt;p&gt;Quando um &lt;code&gt;lvalue&lt;/code&gt; é precedido por um asterisco(&lt;code&gt;*&lt;/code&gt;), isso significa que todos ​​os adicionais &lt;code&gt;rvalues&lt;/code&gt; devem ser colocados em um &lt;code&gt;array&lt;/code&gt; e atribuído ao &lt;code&gt;lvalue&lt;/code&gt;. O valor atribuído a esse &lt;code&gt;lvalue&lt;/code&gt; é sempre um &lt;code&gt;array&lt;/code&gt;, e ele pode ter zero, um ou mais elementos:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
x,*y = 1, 2, 3  # x=1; y=[2,3]
x,*y = 1, 2     # x=1; y=[2]
x,*y = 1        # x=1; y=[]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
No Ruby 1.8, um `splat` só pode preceder o `lvalue` passado na lista. No Ruby 1.9, do lado esquerdo de uma atribuição paralela pode incluem um operador `splat`, mas pode aparecer em qualquer posição na lista:

``` ruby Atribuição
# Ruby 1.9 somente
*x,y = 1, 2, 3  # x=[1,2]; y=3
*x,y = 1, 2     # x=[1]; y=2
*x,y = 1        # x=[]; y=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note-se que &lt;code&gt;splats&lt;/code&gt; pode aparecer em ambos os lados de uma expressão paralela de atribuição:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
x, y, *z = 1, *[2,3,4]  # x=1; y=2; z=[3,4].&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Finalmente, lembre-se que anteriormente descrevemos dois casos simples de atribuição paralela em que há um `lvalue` único ou uma única `rvalue`. Note-se que ambos os casos se comportam como se existe um `splat` antes da única `lvalue` ou `rvalue`. Explicitamente, incluindo um `splat` em nestes casos não tem qualquer efeito adicional.


&amp;lt;h5&amp;gt;Parênteses na atribuição paralelo&amp;lt;/h5&amp;gt;

Uma das características menos compreendidas da atribuição paralela é que o lado esquerdo pode usar parênteses para &amp;quot;sub atrobuição&amp;quot;. Se um grupo de dois ou mais `lvalues` ​​é colocado entre parênteses, então é inicialmente tratada como um `lvalue` único. Uma vez que o `rvalue` correspondente foi determinado, as regras de atribuição paralela são aplicadas recursivamente, o `rvalue` que é atribuído ao grupo de `lvalues` ​​que foi em parênteses. Considere o seguinte exercício:

```ruby Atribuição
x, (y, z) = a, b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este é efetivamente executam dois trabalhos ao mesmo tempo:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
x = a
y,z = b&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Mas note que a segunda tarefa é em si uma atribuição paralela. Como usamos parênteses no lado esquerdo, uma atribuição paralela recursiva é executada. Em ordem para que ele funcione, b deve ser um objeto `splattable` como um `array` ou `enumerador`.

Aqui estão alguns exemplos concretos que devem tornar isso mais claro. Note que os parênteses no ato da esquerda a &amp;quot;desembrulhar&amp;quot; um nível de `array` alinhado à direita:

```ruby Atribuição
x,y,z = 1,[2,3]             # Sem parenteses: x=1;y=[2,3];z=nil
x,(y,z) = 1,[2,3]           # Parenteses: x=1;y=2;z=3

a,b,c,d = [1,[2,[3,4]]]     # Sem parenteses: a=1;b=[2,[3,4]];c=d=nil
a,(b,(c,d)) = [1,[2,[3,4]]] # Parenteses: a=1;b=2;c=3;d=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É isso aí amigos..&lt;/p&gt;

&lt;p&gt;Bons estudos e até a proxima! :D&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>atribuicoes</title>
      <link>http://rodij.me/post/2012/06/03/atribuicoes/</link>
      <pubDate>Sun, 03 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/06/03/atribuicoes/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Atribuições&lt;/p&gt;

&lt;h1&gt;Atribuições&lt;/h1&gt;

&lt;p&gt;Uma expressão de atribuição especifica um ou mais valores para um ou mais valores. lvalue é o termo para algo que pode aparecer no lado
esquerdo de uma atribuição do operador. Os valores no lado direito de um operador de atribuição são algumas vezes chamado de rvalues ​​por
contraste. Variáveis, constantes, atributos e elementos do Array são lvalues ​​em Ruby. As regras para o significado de expressões de
atribuição são um pouco diferente para diferentes tipos de lvalues, e cada tipo é descrito em detalhe neste post.&lt;/p&gt;

&lt;p&gt;Existem três diferentes formas de expressões de atribuição em Ruby. Atribuição simples envolve um lvalue do operador &lt;code&gt;=&lt;/code&gt;, e um rvalue.
Para exemplo:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
x = 1 # Define o lvalue x para o valor 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Atribuição abreviada é uma expressão abreviada que atualiza o valor de uma variável através da aplicação de alguma outro operador (tais
como a adição) ao valor atual da variável. Atribuição abreviada utiliza a atribuição de operadores como &amp;lt;code&amp;gt;+=&amp;lt;/code&amp;gt; e &amp;lt;code&amp;gt;*=&amp;lt;/code&amp;gt; que combinam operadores binários com uma sinal de igual:

``` ruby Atribuição
x += 1 # Define o lvalue x para o valor de x + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por fim, a atribuição paralela é qualquer expressão de atribuição que tem mais do que um lvalue ou mais do que um rvalue. Aqui é um simples exemplo:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
x, y, z = 1,2,3 # Definir x a 1, y a 2 e z a 3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Atribuição paralela é mais complicado quando o número de lvalues não é o mesmo que o número de rvalues ​​ou quando existe um `array` sobre à direita.

O valor de uma expressão de atribuição é o valor (ou um `array` dos valores) atribuído. Além disso, o operador de atribuição
é &amp;quot;Associativo à direita&amp;quot;, se aparecer várias atribuições em uma única expressão, eles são avaliados da direita para a esquerda.
Isto significa que a atribuição pode ser acorrentado para atribuir o mesmo valor para as múltiplas variáveis:

```ruby Atribuição
x = y = 0 # X e Y recebem 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note-se que este não é um caso de atribuição paralela é duas atribuições simples, acorrentados juntos: Y é atribuído o valor 0, e então x é atribuído o valor da primeira tarefa (também 0).&lt;/p&gt;

&lt;h5&gt;Atribuindo a Variáveis&lt;/h5&gt;

&lt;p&gt;Quando nós pensamos em atribuição, geralmente pensamos em variáveis ​​e, na verdade, estes são os mais comuns em expressões de atribuição de lvalues. Lembre-se que Ruby tem quatro tipos de variáveis: variáveis ​​locais, variáveis ​​globais, variáveis ​​de instância e variáveis ​​de classe. Estes são distintas um do outro, pelo primeiro carácter no nome da variável. Atribuição funciona da mesma forma para todos os quatro tipos de variáveis, de modo que não é necessário fazer a distinção entre os tipos de variáveis ​​aqui.&lt;/p&gt;

&lt;p&gt;Tenha em mente que as variáveis ​​de instância de objetos do Ruby são nunca nomes visíveis fora do objeto, e variável nunca é qualificado com um nome de objeto. Considere esta atribuição:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
ponto.x, ponto.y = 1, 2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Os lvalues ​​nesta expressão não são variáveis, são atributos.

Atribuição a uma variável funciona como seria de se esperar: a variável é simplesmente definida como o valor especificado. Ruby não tem nenhuma sintaxe para declarar explicitamente uma variável: variáveis ​​simplesmente vir à existência quando são atribuídas. Assim, uma  expressão simples como X poderia se referir a uma variável local chamada x ou um método chamado x. Para resolver essa ambigüidade, Ruby trata de um identificador como uma variável local se tem visto qualquer trabalho anterior para a variável. Ele faz isso com uma atribuição nunca foi executada. O código a seguir demonstra isso:

```ruby Atribuição
class Ambiguous  
  def x; 1; end # Um método chamado &amp;quot;x&amp;quot;. Sempre retorna 1  

  def teste    
    puts x # Nenhuma variável foi visto, refere-se ao método acima: imprime 1    

    # A linha abaixo não é avaliada, por causa da cláusula &amp;quot;if falsa&amp;quot;.
    # Mas o analisador vê e trata x como uma variável para o resto do método.    
    x = 0 if false

    puts x # x é uma variável, mas nunca foi atribuído: irá imprimir nil

    x = 2 # Esta atribuição não é avaliada
    puts x # Então agora esta linha imprime 2  
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Atribuindo a Constantes&lt;/h5&gt;

&lt;p&gt;Constantes são diferentes das variáveis ​​de uma forma óbvia: seus valores são destinados a permanecer constante durante a execução de um programa. Portanto, existem algumas regras especiais para a atribuição de constantes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* Atribuição a uma constante que já existe, faz com o Ruby emita um aviso. O Ruby executa a tarefa,
no entanto, que significa que as constantes não são realmente constante.

* Atribuição a constantes não é permitido dentro do corpo de um método. Ruby assume que os métodos
destinados a ser invocados mais de uma vez, se você poderia atribuir a uma constante em um método,
que método ira emitir alertas a cada requisição após a primeira.  Então, isso simplesmente não é
permitido.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ao contrário das variáveis, as constantes não vem a existir até que o &lt;code&gt;Intérprete Ruby&lt;/code&gt; realmente executa a expressão de atribuição. A expressão não avaliada abaixo, não cria uma constante:&lt;/p&gt;

&lt;p&gt;```ruby Atribuiçao de Constante
N = 100 if false&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Note-se que isto significa que uma constante nunca está em um estado de inicialização. Se uma constante existe, então ele tem um valor atribuído a ela. A constante só terá valor se o valor realmente for `nil`.



&amp;lt;h5&amp;gt;Atribuindo a Atributos e elementos de Array&amp;lt;/h5&amp;gt;

Atribuição a um atributo ou um elemento de um `Array` é na verdade uma abreviação do Ruby para a invocação método. Suponha que um objeto tem um método chamado `m=:`, o nome do método tem um sinal de igual como seu último caractere. Em seguida, `o.m` pode ser usado como um lvalue em uma expressão de atribuição. Suponha, além disso, que o valor v é atribuído:

```ruby Atribuição
o.m = v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O interpretador Ruby converte essa tarefa para a seguinte invocação de método:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
o.m=(v) # Se omitir os parênteses e adicionar um espaço, isso parece tarefa!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Isto é, ele passa o valor v para o método `m=`. Esse método pode fazer o que quiser com o valor. Normalmente, ele irá verificar que o valor é de desejado tipo e dentro da gama desejada, e, em seguida, armazená-lo em uma variável de instância do objeto. Métodos como `m=` são geralmente acompanhados de um método `m`, que simplesmente retorna o valor mais recentemente passado para `m=`. Alguns dizem que `m=` é um método setter e `m` é um método getter. Quando um objeto tem esse par de métodos, dizemos que ele tem um atributo `m`. Atributos são às vezes chamado de &amp;quot;Propriedades&amp;quot; em outras línguas.

Atribuindo valores aos elementos de um `Array` também é feito pelo método de invocação. Se um objeto define um método chamado `[]=` (nome do método é apenas esses três caracteres de pontuação) que espera dois argumentos, então na expressão o `[x] = y` é realmente executado como:

```ruby Atribuição
o.[]= (x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se um objeto tem um método &lt;code&gt;[]=&lt;/code&gt; que espera três argumentos, então ele pode ser indexado com dois valores entre os colchetes. As dois seguintes expressões são equivalentes neste caso:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
o[x, y] = z
o.[] = (x, y, z)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;h5&amp;gt;Atribuição Abreviada&amp;lt;/h5&amp;gt;

Atribuição Abreviada é uma forma de atribuição que combina atribuição com alguns outras operações. Ele é usado mais comumente para incrementar variáveis:

```ruby Atribuição Abreviada
x += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O &lt;code&gt;+=&lt;/code&gt;, não é um operador real de Ruby, e a expressão acima é simplesmente uma abreviatura para:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição Abreviada
x = x + 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Atribuição Abreviada não pode ser combinado com paralelo de atribuição: ela só funciona quando há um único lvalue à esquerda e um único valor do lado direito. Ela não deve ser usado quando o lvalue é uma constante, porque ele vai reatribuir a constante e causar um aviso. Atribuição abreviada pode, contudo, ser utilizado quando o lvalue é um atributo. As duas expressões a seguir são equivalentes:

```ruby Atribuição Abreviada
o.m += 1
o.m=(o.m()+1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Atribuição abreviada funciona até mesmo quando o lvalue é um elemento de um &lt;code&gt;array&lt;/code&gt;. Estas duas expressões são equivalente:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Atribuição Abreviada
o[x] -= 2
o.[]=(x, o.[](x) - 2)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Observe que esse código usa &lt;code&gt;-=&lt;/code&gt; em vez de &lt;code&gt;+=&lt;/code&gt;. Como você poderia esperar, o &lt;code&gt;-=&lt;/code&gt; é pseudooperator que subtrai seu rvalue a partir do seu lvalue.&lt;/p&gt;

&lt;p&gt;Além &lt;code&gt;+=&lt;/code&gt; e &lt;code&gt;-=&lt;/code&gt;, há outros 11 pseudooperators que podem ser usados ​​para atribuição abreviada. Eles são listados abaixo. Note-se que estes não são verdadeiros operadores próprios, eles são simplesmente uma abreviação para expressões que usam outros operadores. Muitos desses outros operadores são definidos como métodos. Se uma classe define um método chamado &lt;code&gt;+&lt;/code&gt;, por exemplo, em seguida, que as alterações do sentido da Atribuição abreviada com &lt;code&gt;+=&lt;/code&gt; para todas as instâncias dessa classe.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Atribuição                          Expansão
x += y                              x = x + y
x -= y                              x = x - y
x *= y                              x = x * y
x /= y                              x = x / y
x %= y                              x = x % y
x **= y                             x = x ** y
x &amp;amp;&amp;amp;= y                             x = x &amp;amp;&amp;amp; y
x ||= y                             x = x || y
x &amp;amp;= y                              x = x &amp;amp; y
x |= y                              x = x | y
x ^= y                              x = x ^ y
x &amp;lt;&amp;lt;= y                             x = x &amp;lt;&amp;lt; y
x &amp;gt;&amp;gt;= y                             x = x &amp;gt;&amp;gt; y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É isso aí amigos&amp;hellip; até o proximo post!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>invocacoes de metodo</title>
      <link>http://rodij.me/post/2012/06/02/invocacoes-de-metodo/</link>
      <pubDate>Sat, 02 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/06/02/invocacoes-de-metodo/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas&lt;/p&gt;

&lt;h1&gt;Invocações de método&lt;/h1&gt;

&lt;p&gt;Uma expressão de invocação de método tem quatro partes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Uma expressão arbitrária cujo valor é o objeto no qual o método é chamado. Esta expressão é seguido por . ou :: para separá-lo a partir
do nome do método que se segue. A expressão e o separador são opcionais; se omitido, o método é invocada em si mesmo.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;O nome do método a ser invocado. Este é o único pedaço exigido de uma expressão chamada de método.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Valores com o argumento passado para o método. A lista de argumentos podem ser colocados entre parênteses, mas estes são geralmente
opcionais. Se há mais de um argumento, eles são separados uns dos outros com vírgulas. O número e tipo de argumentos necessários
dependem da definição do método. Alguns métodos podem ser chamodos sem argumentos.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Um bloco opcional de código delimitado por chaves ou por um par &lt;code&gt;do/end&lt;/code&gt;. O método pode invocar esse código usando a palavra-chave de
&lt;code&gt;yield&lt;/code&gt;. Esta capacidade de associar código arbitrário com qualquer invocação de método é a base para métodos poderosos em Ruby.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Um nome do método é normalmente separado do objeto sobre o qual é chamado com um &lt;code&gt;..&lt;/code&gt;, e com o &lt;code&gt;::&lt;/code&gt;, que também é permitido, mas é raramente
usado porque pode fazer invocações de método parecem mais com referênciar constantes expressões.&lt;/p&gt;

&lt;p&gt;Quando o interpretador Ruby tem o nome de um método e um objeto em que deve ser invocado, ele encontra a definição adequada do método
chamado usando um processo conhecido como &amp;ldquo;método de pesquisa&amp;rdquo; ou &amp;ldquo;resolução de nome do método.&amp;rdquo; Os detalhes não são importantes aqui,
mas eles são explicados completamente no método de pesquisa.&lt;/p&gt;

&lt;p&gt;O valor de uma invocação expressão de método é o valor da expressão avaliada pelo último método no corpo do código. Aqui, no entanto, são
alguns exemplos de invocações de método:&lt;/p&gt;

&lt;p&gt;```ruby Ruby
puts &amp;ldquo;Olá mundo&amp;rdquo; # &amp;ldquo;puts&amp;rdquo; invocado em auto, com uma seqüência de arg
Math.sqrt(2) # &amp;ldquo;sqrt&amp;rdquo; invocado em Matemática objeto com uma arg
message.length # &amp;ldquo;comprimento&amp;rdquo; invocado em mensagem objeto; não args
a.each{|x| p x} # &amp;ldquo;cada&amp;rdquo; chamado em um objeto, com um bloco associado&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Um dos exemplos do método de invocação mostradas anteriormente foi &amp;lt;code&amp;gt;message.length&amp;lt;/code&amp;gt;. Você pode ser tentado a pensar-lo como uma variável
de expressão de referência, avaliando para o valor do comprimento da variável do objeto mensage. Este não é o caso, no entanto, Ruby tem
um modelo de programação muito orientada a objetos: objetos em Ruby podem encapsular qualquer número de variáveis ​​de instância interna,
mas expõem métodos apenas para o mundo exterior. Como o método &amp;lt;code&amp;gt;length&amp;lt;/code&amp;gt; não espera argumentos e é chamado sem os parênteses opcionais,
parece que referência uma variável. Na verdade, isso é intencional. Métodos como estes são chamados para atribuir métodos de acesso, e
dizemos que o objeto da &amp;lt;code&amp;gt;mensage&amp;lt;/code&amp;gt; tem um atributo de &amp;lt;code&amp;gt;lenght&amp;lt;/code&amp;gt;. Como veremos, é possível que o objeto de &amp;lt;code&amp;gt;mensage&amp;lt;/code&amp;gt;
para definir um método chamado &amp;lt;code&amp;gt;length=&amp;lt;/code&amp;gt;. Se este método espera um único argumento, então é um método setter do atributo e
Ruby invoca em resposta a atribuição. Se um tal método é definido, então estas duas linhas de código seria tanto chamar o mesmo método:

```ruby Length
message.length=(3) # invocação do método tradicional
message.length = 3 # invocação Método como a atribuição
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora, considere a seguinte linha de código, assumindo que uma variável contém um &lt;code&gt;Array&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;```ruby Array
a[0]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Você pode pensar novamente que este é um tipo especial de variável de referência, onde a variável em questão é na verdade um elemento do
&amp;lt;code&amp;gt;Array&amp;lt;/code&amp;gt;. Novamente, no entanto, esta é invocação do método. O intérprete Ruby converte o acesso ao &amp;lt;code&amp;gt;Array&amp;lt;/code&amp;gt; para isso:

```ruby Array
a.[](0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O acesso ao &lt;code&gt;Array&lt;/code&gt; torna-se uma invocação do método chamado &lt;code&gt;[]&lt;/code&gt;, com o índice do &lt;code&gt;Array&lt;/code&gt; como seu
argumento. Esta sintaxe de acesso de &lt;code&gt;Array&lt;/code&gt; não se limita a &lt;code&gt;Arrays&lt;/code&gt;. Qualquer objeto é permitido para definir um
método chamado &lt;code&gt;[]&lt;/code&gt;. Quando o objeto é &amp;ldquo;indexado&amp;rdquo;, com o indix entre parênteses, os valores dentro dos parênteses será passado
para o método. Se o método &lt;code&gt;[]&lt;/code&gt; é escrito para esperar três argumentos, então você deve colocar três expressões separados por
vírgula dentro dos colchetes.&lt;/p&gt;

&lt;p&gt;Atribuição de &lt;code&gt;Arrays&lt;/code&gt; também é feito através de invocação de método. Se o objeto o define um método chamado &lt;code&gt;[]=&lt;/code&gt;, então a expressão &lt;code&gt;o[x] = y&lt;/code&gt; torna-se &lt;code&gt;o.[] = (x, y)&lt;/code&gt;, e a expressão &lt;code&gt;o[x, y] = z&lt;/code&gt; se torna &lt;code&gt;o.[] = (x , y, z)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Muitos operadores do Ruby são definidos como métodos, e expressões como &lt;code&gt;x + y&lt;/code&gt; são avaliados como &lt;code&gt;x.+(y)&lt;/code&gt;, onde o
nome de método é &lt;code&gt;+&lt;/code&gt;. O fato de que muitos dos operadores do Ruby são definidos como métodos que significa você pode redefinir
esses operadores na sua próprias classes.&lt;/p&gt;

&lt;p&gt;Agora, vamos considerar esta expressão muito simples:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Ruby
x
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Se uma variável x nomeada existe (Isto é, se o interpretador Ruby tem visto uma atribuição a x), então esta é uma variável de referência.
Se nenhuma variável existe, então esta é uma invocação do método x, sem argumentos.&lt;/p&gt;

&lt;p&gt;A palavra &lt;code&gt;super&lt;/code&gt; em Ruby é um tipo especial de invocação de método. Esta palavra é usada ao criar uma subclasse de outra
classe. Por si só, &lt;code&gt;super&lt;/code&gt; passa os argumentos do método corrente para o método com o mesmo nome na superclasse. Ele também
pode ser usado como se fosse realmente o nome de um método e pode ser seguido por uma lista de argumentos arbitrários. A palavra-chave
&lt;code&gt;super&lt;/code&gt; é abordada em detalhes no Aumentando Comportamento por encadeamento.&lt;/p&gt;

&lt;p&gt;Até a Proxima&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>variaveis nao inicializadas</title>
      <link>http://rodij.me/post/2012/06/02/variaveis-nao-inicializadas/</link>
      <pubDate>Sat, 02 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/06/02/variaveis-nao-inicializadas/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas&lt;/p&gt;

&lt;h1&gt;Variáveis ​​não inicializadas&lt;/h1&gt;

&lt;p&gt;Em geral, você deve sempre atribuir um valor para, ou inicializar as variáveis ​​antes de usá-las em expressões. Em algumas circunstâncias,
no entanto, Ruby lhe permitirá utilizar variáveis ​​que ainda não foram inicializadas. As regras são diferentes para diferentes tipos de variáveis:&lt;/p&gt;

&lt;p&gt;&lt;h4&gt;Variáveis ​​de classe&lt;/h4&gt;
    Variáveis ​​de classe deve sempre ter um valor atribuído a elas antes que serem utilizadas. Ruby levanta uma NameError se
    referir a uma variável de classe à qual nenhum valor foi atribuído.&lt;/p&gt;

&lt;p&gt;&lt;h4&gt;Variáveis ​​de instância&lt;/h4&gt;
    Se você se referir a uma variável de instância não inicializada, Ruby retorna nil. Considera-se má programação de
    contar com esse comportamento, no entanto. Ruby vai emitir um aviso sobre a variável não inicializada se você executá-la
    com a opção -w.&lt;/p&gt;

&lt;p&gt;&lt;h4&gt;As variáveis ​​globais&lt;/h4&gt;
    Variáveis ​​globais não inicializadas são como o exemplo de variáveis não inicializadas: elas igualam a nil, mas mostra
    um aviso quando o Ruby é executado com o flag do -w.&lt;/p&gt;

&lt;p&gt;&lt;h4&gt;As variáveis ​​locais&lt;/h4&gt;
    Este caso é mais complicado que os outros, porque variáveis locais ​​não têm um caractere de pontuação como um prefixo.
    Este significa que variáveis ​​locais referênciam olhando apenas como uma invocação de método de expressões. Se o
    interpretador Ruby tem visto uma atribuição de uma variável local, ele sabe que é uma variável e não um método,
    e pode retornar o valor da variável. Se não tiver havido nenhuma atribuição, então o Ruby trata a expressão como uma
    invocação de método. Se nenhum método com esse nome existe, Ruby levanta um NameError.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Em geral, portanto, a tentativa de usar uma variável local antes de ter sido inicializada resulta em um erro. Existe
uma peculiaridade, uma variável passa a existir quando o interpretador Ruby vê uma expressão de atribuição para essa
variável. Este é o caso, mesmo se essa atribuição não é realmente executada. A variável que existe, mas não foi
atribuído um valor, é dado o valor nulo como padrão. Por exemplo:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ruby Variaveis
a = 0.0 if false # atribuição Isso nunca é executado
puts a # Imprime nulo: a variável existe mas não é atribuída
puts b # NameError: nenhuma variável ou método chamado existe b
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html&#34;&gt;Variaveis Ruby 1.9.2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Até a próxima.. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>variaveis de referencia</title>
      <link>http://rodij.me/post/2012/06/01/variaveis-de-referencia/</link>
      <pubDate>Fri, 01 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/06/01/variaveis-de-referencia/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Variáveis de Referência&lt;/p&gt;

&lt;h1&gt;Variáveis de Referência&lt;/h1&gt;

&lt;p&gt;Uma variável é simplesmente um nome para um valor. As variáveis ​​são criadas e os valores que lhes são atribuídos por expressões
de atribuição. Quando o nome de uma variável aparece num programa em qualquer lugar que não seja o lado esquerdo de uma atribuição, é uma
variável de referência à expressão e avaliado como o valor da variável:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Referência
one = 1.0 # Esta é uma atribuição de expressão
one # Essa referência de expressão da variável, que imprimi 1.0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Existem quatro tipos de variáveis ​​em Ruby, e regras &lt;a href=&#34;http://pt.wikipedia.org/wiki/Item_lexical&#34;&gt;lexicais&lt;/a&gt; para governar seus nomes. Variáveis que começam com $ são variáveis ​​globais, visível ao longo de um programa Ruby. Variáveis ​​que começam com @ e @@ são
variáveis ​​de instância e variáveis ​​de classe, usado em programação orientada a objeto. E as variáveis ​​cujos nomes começam com um sublinhado
ou uma letra minúscula são variáveis ​​locais, definidas apenas dentro do atual método ou bloco.&lt;/p&gt;

&lt;p&gt;Variáveis ​​sempre são simples, nomes não qualificados. Se um . ou :: aparece em uma expressão, em seguida, que a expressão é ou um
uma referência a uma constante ou uma invocação de método. Por exemplo, Math::PI é uma referência a uma constante, e a expressão
item.preco é uma invocação do método chamado preco (preço) sobre o valor realizado pela variável item.&lt;/p&gt;

&lt;p&gt;O interpretador Ruby predefine um número de variáveis ​​globais quando ele é iniciado.&lt;/p&gt;

&lt;p&gt;Até a próxima.. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>literais e palavras chaves literais</title>
      <link>http://rodij.me/post/2012/05/27/literais-e-palavras-chaves-literais/</link>
      <pubDate>Sun, 27 May 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/05/27/literais-e-palavras-chaves-literais/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Literais e Plavras-chaves literais&lt;/p&gt;

&lt;h1&gt;Literais e Plavras-chaves literais&lt;/h1&gt;

&lt;p&gt;Literais são valores como 1.0, &amp;ldquo;Hello world&amp;rdquo;, e [] que são incorporados diretamente em seu texto do programa.&lt;/p&gt;

&lt;p&gt;É interessante notar que muitos literais, tais como números, são as principais expressões - as expressões mais simples possíveis não
compostas de expressões simples. Literais, tais como Array e literais de hash e strings duplas citadas que usam interpolação, incluem
sub-expressões e são, portanto, expressões não primárias.&lt;/p&gt;

&lt;p&gt;Determinadas palavras-chave em Ruby são expressões primárias e podem ser considerados palavras-chave literais ou formas especializadas
de referência da variável:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nil            -&amp;gt;   Avalia o valor nulo, de NilClass classe.
true           -&amp;gt;   Avalia-se à instância singleton da Classe TrueClass, que um objeto representa o valor booleano
                    verdadeiro.
false          -&amp;gt;   Avalia-se à instância singleton da Classe FalseClass, que um objeto representa os valores booleanos
                    falsos.
self           -&amp;gt;   Auto avalia o objeto atual.
__FILE__       -&amp;gt;   Avalia a uma string que nomeia o arquivo que o Ruby Intérprete (IRB) está em execução. Isto pode ser
                    útil em erro de mensagens.
__LINE__       -&amp;gt;   Avalia como um inteiro que especifica o número da linha dentro da linha do código atual do __FILE__.
__ENCODING__   -&amp;gt;   Avalia a um objeto Encoding que especifica a codificação do arquivo atual. (Ruby 1.9 apenas.)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É isso ai galera, até o proximo post.. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>aexpressoes e operadores o inicio</title>
      <link>http://rodij.me/post/2012/05/23/aexpressoes-e-operadores-o-inicio/</link>
      <pubDate>Wed, 23 May 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/05/23/aexpressoes-e-operadores-o-inicio/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Expressões e Operadores&lt;/p&gt;

&lt;h1&gt;Expressões e Operadores&lt;/h1&gt;

&lt;p&gt;Uma expressão é um pedaço de código Ruby que o interpretador Ruby pode avaliar para produzir um valor. Aqui estão alguns exemplos
de expressões:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Expressões
2 # Um literal numérico
x # Uma referência variável local
Math.sqrt(2) # invocação Um método
x = Math.sqrt(2) # Atribuição
x * x # Multiplicação com o operador *
&lt;/code&gt;
Como você pode ver, expressões primárias, tal como literais, referências variáveis, e invocações de método podem ser combinadas em
expressões maiores com operadores, tais como o operador de atribuição e o operador de multiplicação.&lt;/p&gt;

&lt;p&gt;Muitas linguagens de programação diferenciam entre expressões de baixo nível e alto nível de declarações, tais como condicionais e loops.
Nestas linguagens, as declarações de controlar o fluxo de um programa, mas eles não têm valores. Eles são executados, em vez de avaliados.
Em Ruby, não há distinção clara entre as afirmações e expressões; tudo em Ruby, incluindo a definição de classe e de método, pode ser
avaliado como uma expressão e retorna um valor. É ainda útil, no entanto, diferenciam sintaxe normalmente usada como expressões de sintaxe
tipicamente usadas ​​como indicações.&lt;/p&gt;

&lt;p&gt;Até mais amigos.. ainda vem muito conteudo legal com por ai.. :D&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>classe objects em ruby 1 dot 9 2 part iv</title>
      <link>http://rodij.me/post/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-iv/</link>
      <pubDate>Sun, 20 May 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-iv/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Object.html&#34;&gt;Objects&lt;/a&gt;, é hora de nos aprofundar.&lt;/p&gt;

&lt;h1&gt;Objetos&lt;/h1&gt;

&lt;h3&gt;Ordem de Object&lt;/h3&gt;

&lt;p&gt;Praticamente todas as classes podem definir o método ==, sendo útil para testar as suas instâncias para a igualdade. Algumas
classes também podem definir uma ordenação. Ou seja: para quaisquer duas instâncias de uma classe, as duas instâncias devem ser iguais,
ou uma instância deve ser &amp;ldquo;menos que&amp;rdquo; a outra. Numbers são das classes mais óbvias para que tal ordenação seja definido.
String são também ordena, de acordo com o numéro de ordenação dos códigos de caracteres que compõem as strings. Se uma classe define
uns casos de pedido, em seguida, a classe pode ser comparada e classificada.&lt;/p&gt;

&lt;p&gt;Em Ruby, classes definem um ordenação através da implementação do operador &amp;lt;=&amp;gt;. Este operador deve retornar -1 se o operando da esquerda
é menor que o operando da direita, 0 se os dois operandos são iguais, e 1 se o operando esquerdo é maior que o operando direito.
Se os dois operandos não podem ser   significativamente comparados (se o operando direito é de uma classe diferente, por exemplo),
em seguida, o operador deve retornar nil:&lt;/p&gt;

&lt;p&gt;``` ruby Operador &amp;lt;=&amp;gt;
1 &amp;lt;=&amp;gt; 5 # -1
5 &amp;lt;=&amp;gt; 5 # 0
9 &amp;lt;=&amp;gt; 5 # 1
&amp;ldquo;1&amp;rdquo; &amp;lt;=&amp;gt; 5 # nil: inteiros e strings não são comparáveis&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
O operador &amp;lt;=&amp;gt; é tudo que é necessário para comparar os valores. Mas não é particularmente intuitivo. Assim, as classes que definem
este operador tipicamente também incluir o Módulo &amp;lt;a href=&amp;quot;http://ruby-doc.org/core-1.9.2/Comparable.html&amp;quot;&amp;gt;Comparable&amp;lt;/a&amp;gt; como um mixin.
(Módulos e mixins são abordados em Módulos como Mixins). O mixin Comparable define o seguinte operador em termos de &amp;lt;=&amp;gt;:

	&amp;lt; 	-	Menor que
	&amp;lt;=	-	Menor ou igual
	==	-	Igual
	&amp;gt;=	-	Maior ou igual
	&amp;gt;	-	Maior que

&amp;lt;a href=&amp;quot;http://ruby-doc.org/core-1.9.2/Comparable.html&amp;quot;&amp;gt;Comparable&amp;lt;/a&amp;gt; não define o operador !=; o Ruby automaticamente define o
operador como a negação do operador ==. Além destes operadores de comparação, &amp;lt;a href=&amp;quot;http://ruby-doc.org/core-1.9.2/Comparable.html&amp;quot;&amp;gt;Comparable&amp;lt;/a&amp;gt; também define um método útil de comparação com o between? :

``` ruby Comparable between?
1.between?(0,10) # verdadeiro: 0 &amp;lt;= 1 &amp;lt;= 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se o operador &amp;lt;=&amp;gt; retornar nil, todos os operadores de comparação dele derivados retornam falso. O especial Float com valor NaN é um exemplo:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Float NaN
nan = 0.0/0.0; # zero dividido por zero não é um número
nan &amp;lt; 0 # false: não é menor que zero
nan &amp;gt; 0 # false: não é maior que zero
nan == 0 # false: não é igual a zero
nan == nan # false: não é mesmo igual a si mesmo!
nan.equal?(nan) # isso é verdade, claro
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Observe que a definição de &amp;lt;=&amp;gt; e incluindo o módulo &lt;a href=&#34;http://ruby-doc.org/core-1.9.2/Comparable.html&#34;&gt;Comparable&lt;/a&gt; define um operador == para o sua classe. Algumas classes que definem o seu próprio operador ==, normalmente quando eles podem
implementar esta forma mais eficiente do que um teste de igualdade com base no operador &amp;lt;=&amp;gt;. É possível definir classes que
implementam diferentes noções de igualdade em seus operadores == e &amp;lt;=&amp;gt;. Uma classe pode fazer comparações de string case-sensitive
para o operador ==, por exemplo, mas, em seguida, fazem comparações de maiúsculos e minúsculos com &amp;lt;=&amp;gt;, de modo que as instâncias da classe
se classificam com mais naturalidade. Em geral, porém, é melhor se &amp;lt;=&amp;gt; retorna 0 se e somente se == retorna true.&lt;/p&gt;

&lt;p&gt;É isso amigos&amp;hellip; o proximo post vamos conversar um pouco de Conversões de Object&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;Até Mais..&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>classe objects em ruby 1 dot 9 2 part v</title>
      <link>http://rodij.me/post/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-v/</link>
      <pubDate>Sun, 20 May 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-v/</guid>
      <description>

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Object.html&#34;&gt;Objects&lt;/a&gt;, é hora de nos aprofundar.&lt;/p&gt;

&lt;h1&gt;Objetos&lt;/h1&gt;

&lt;h3&gt;Conversão de objetos&lt;/h3&gt;

&lt;p&gt;Muitas classes de Ruby definem métodos que retornam uma representação do objeto como um valor de uma classe diferente.
O método to_s, para a obtenção de uma representação de um objeto, é provavelmente o mais comumente implementado e mais conhecido
dos métodos. As subseções a seguir descrevem várias categorias de conversões.&lt;/p&gt;

&lt;h5&gt;Conversões explícitas&lt;/h5&gt;

&lt;p&gt;As classes definem métodos de conversão explícitos para uso da aplicação de código que precisa de converter um valor para uma
outra representação. Os métodos mais comuns nesta categoria são to_s, to_i, to_f e to_a para converter a String, Integer, Float,
e array, respectivamente. Ruby 1.9 adiciona métodos to_c e to_r que se converterem ao &lt;a href=&#34;http://ruby-doc.org/stdlib-1.9.2/libdoc/syck/rdoc/Complex.html&#34;&gt;Complex&lt;/a&gt; e &lt;a href=&#34;http://ruby-doc.org/stdlib-1.9.2/libdoc/bigdecimal/rdoc/Rational.html&#34;&gt;Rational&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Métodos built-in normalmente não chamam esses métodos para você. Se você chamar um método que espera uma String e passar um objeto
de algum outro tipo, que o método não é esperado para converter o argumento com to_s. (Valores interpolados em aspas dupla em strings,
no entanto, são automaticamente convertidos com to_s.)&lt;/p&gt;

&lt;p&gt;to_s é facilmente o mais importantes dos métodos de conversão, porque representações de seqüência de objetos são tão comumente
utilizadas em interfaces de usuário. Uma importante alternativa para to_s é o método inspect. to_s é geralmente destinados a retornar uma
representação legível do objeto, adequado para usuários finais. inspect, por outro lado, é destinados ao uso de depuração, e deve
retornar uma representação que é útil para os desenvolvedores de Ruby. O padrão do método inspect, herdado de Object, simplesmente chama
to_s.&lt;/p&gt;

&lt;h5&gt;As conversões implícitas&lt;/h5&gt;

&lt;p&gt;Às vezes, uma classe tem características fortes de uma outra classe. A classe Exception de Ruby representa um erro ou condição
inesperada em um programa e encapsula uma mensagem de erro. No Ruby 1.8, objetos Exception não são apenas conversível para strings,
que são strings como objetos e podem ser tratadas como se fossem strings em muitos contextos [*], Por exemplo:&lt;/p&gt;

&lt;p&gt;``` ruby class Exception&lt;/p&gt;

&lt;h1 id=&#34;ruby-1-8&#34;&gt;Ruby 1.8&lt;/h1&gt;

&lt;p&gt;e = Exception.new(&amp;ldquo;não é realmente uma exceção&amp;rdquo;)
msg = &amp;ldquo;Erro:&amp;rdquo; + e # concatenação de String com uma exceção&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Como os objetos de exceção são strings, eles podem ser usados ​​com a cadeia no operador de concatenação. Isso não funciona com a
maioria das outras classes de Ruby. A razão pela qual os objetos de Exceção pode se comportar como Objetos String é que, em Ruby
1.8, Exception implementa o método to_str, implícito de conversão, e o operador + definido pela String chama esse método em seu
do lado direito do operando.

Outros métodos de conversão implícitos são to_int para objetos que querem ser inteiro, como to_ary, para objetos que quer ser
array, e to_hash para objetos que querem ser hash. Infelizmente, as circunstâncias em que estes métodos de conversão são implícitos
chamados não são bem documentados. Entre as classes embutidas, estes métodos de conversões implícitas que normalmente não são implementadas, tampouco.

Observamos anteriormente, de passagem, que o operador == pode realizar um tipo fraco de tipo de conversão ao testar a igualdade.
Os operadores == definidos pelo Array, String, e Hash para ver se o operando do lado direito é da mesma classe como o operando esquerdo.
Se assim for, eles se comparam. Se não, verifica se o operando do lado direito tem um to_str, to_ary, ou método to_hash.
Eles não invocam estes métodos, mas se eles existem, eles invocam o método == do operando do lado direito e permiti que ele se decida
se é igual ao do operando esquerda.

No Ruby 1.9, as classes String, Array, Hash, RegExp e IO definiem tudas um método de classe chamado try_convert. Este métodos
convertem seu argumento se definido um método implícito apropriado de conversão, ou retorna contrário nil . Array.try_convert(o)
retorna o.to_ary se o método define, caso contrário, retorna nil. Estes métodos são try_convert conveniente se você quiser escrever
métodos que permitem conversões implícitas no seu argumento.

&amp;lt;h5&amp;gt;Funções de conversão&amp;lt;/h5&amp;gt;

O módulo de Kernel define quatro métodos de conversão que se comportam como funções globais de conversão. Estas funções de array, Float,
Integer e String, têm os mesmos nomes que as classes para que se convertam, e eles são incomuns em que eles começam com uma
letra maiúscula.

A função Array tenta converter seu argumento para um array chamando to_ary. Se esse método é não definido ou retorna nil, ou ele tenta
o método to_a. Se to_a não está definido retorna nulo, a função Array simplesmente retorna um novo array contendo o argumento como
seu único elemento.

A função Float converte argumentos numéricos para objetos Float diretamente. Para qualquer valor não numérico, que chama o método to_f.

A função Integer converte o argumento para um Fixnum ou Bignum. Se o argumento é um valor numérico, ele é convertido diretamente. Valores
de Float são truncados e não arredondado. Se o argumento é uma string, ele procura por um indicador de radix(um condutor 0 para octal,
0x para hexadecimal, ou 0b para binário) e converte a string em conformidade. Ao contrário String.to_i não permiti caracteres não
numéricos à direita. Para qualquer outro tipo de argumento, a função Integer tenta converter primeiro com to_int e depois com to_i.

Finalmente, a função String converte o argumento para uma string simplesmente chamando seu método to_s.

&amp;lt;h5&amp;gt;Tipo de operador Aritmético&amp;lt;/h5&amp;gt;

Tipos numéricos definem um método de conversão chamado &amp;lt;a href=&amp;quot;http://www.ruby-doc.org/core-1.9.2/Numeric.html#method-i-coerce&amp;quot;&amp;gt;coerce&amp;lt;/a&amp;gt;. A intenção deste método é o de converter o argumento para o mesmo tipo como o objeto numérico no qual o método é invocado, ou
para converter ambos os objetos para algum tipo mais geralmente compatíveis. O método de coerce sempre retorna uma matriz que tem dois
valores numéricos do mesmo tipo. O primeiro elemento do array é o valor convertido do argumento para coerce. O segundo elemento do
retornado do array é o valor(convertido, se necessário) em que foi invocado coerce:

``` ruby Coerc
1.1.coerce(1) # [1.0, 1.1]: coagir Fixnum para Flutuar
require &amp;quot;rational&amp;quot; # Use números racionais
r = Rational(1,3) # terceira Um como um número racional
r.coerce (2) # [Rational (2,1), Rational (1,3)]: Fixnum para Rational
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O método coerce é usado pelos operadores aritméticos. O operador + definido por Fixnum não sabe sobre números Rational, por exemplo, e se
o operando do lado direito é um valor rational, não se sabe como adicionar. coerce fornece a solução. Operadores numéricos são escritos
de modo que, se eles não sabem o tipo do operando do lado direito, que invocam o método coerce do operando do lado direito, passando o
operando da esquerda como um argumento. Voltando ao nosso exemplo de adição de um Fixnum e um Rational, o método coerce de Rational
retorna um array de dois valores racionais. Agora, o operador + definido por Fixnum pode simplesmente invocar + sobre os valores no array.&lt;/p&gt;

&lt;h5&gt;Conversões de tipos Booleanos&lt;/h5&gt;

&lt;p&gt;Valores booleanos merecem uma menção especial no contexto de conversão de tipo. Ruby é muito rigoroso com seus valores booleanos: true e
falso têm métodos to_s, que retornam &amp;ldquo;true&amp;rdquo; e &amp;ldquo;falso&amp;rdquo;, mas definem nenhum outro método de conversão. E não há nenhum método to_b
para converter os outros valores para Booleanos.&lt;/p&gt;

&lt;p&gt;Em algumas Linguagens, é falsa a mesma coisa que 0, ou pode ser convertidos para 0. Em Ruby, os valores verdadeiros e falsos são os
seus próprios objetos distintos, e não existem conversões implícitas que convertem os outros valores para verdadeiro ou falso.
Esta é apenas metade da história, no entanto. Operadores booleanos de Ruby e de sua condicional e construções em loops que usam
expressões booleanas podem trabalhar com outros valores que o verdadeiro e o falso. A regra é simples: em expressões Boolean, qualquer
valor diferente de false ou nil se comporta como (mas não é convertida em) verdadeiro. nil, por outro lado se comporta como falsa.&lt;/p&gt;

&lt;p&gt;Suponha que você queira testar se a variável x é nula ou não. Em algumas línguagens, você deve escrever explicitamente uma expressão
de comparação que avalia a verdadeira ou falso:&lt;/p&gt;

&lt;p&gt;```ruby True ou False
if x != nil #  a expressão &amp;ldquo;x! = nil&amp;rdquo; retorna true ou false para o caso
  puts x # x Imprimir se ela é definida
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Esse código funciona em Ruby, mas é mais comum simplesmente para tomar vantagem do fato de que todos os outros valores do que zero e
falso se comportam como verdadeiras:

``` ruby True ou False
if x # Se x é não-nula
  puts x # Em seguida, imprimi-lo
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É importante lembrar que os valores como 0, 0.0, e uma string vazia &amp;ldquo;&amp;rdquo; comportam-se como verdadeiro em Ruby, que é surpreendente se você
está acostumado a linguagens como C ou JavaScript.&lt;/p&gt;

&lt;p&gt;É isso amigos&amp;hellip;&lt;/p&gt;

&lt;p&gt;Até Mais..&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>classe objects em ruby 1 dot 9 2 part vi</title>
      <link>http://rodij.me/post/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-vi/</link>
      <pubDate>Sun, 20 May 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-vi/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Object.html&#34;&gt;Objects&lt;/a&gt;, é hora de nos aprofundar.&lt;/p&gt;

&lt;h1&gt;Objetos&lt;/h1&gt;

&lt;h3&gt;Copiando objetos&lt;/h3&gt;

&lt;p&gt;A classe Object define dois métodos estreitamente relacionados para copiar objetos. Tanto o clone e como o dup retornar uma cópia
superficial do objeto em que eles são chamados. Se o objeto copiado inclui o estado interno que se refere a outros objetos, apenas as
referências a objetos são copiadas, não os próprios objetos referenciados.&lt;/p&gt;

&lt;p&gt;Se o objecto a ser copiado define um método initialize_copy, em seguida, clone e dup simplesmente alocam uma nova instância vazia da
classe e chamam o método initialize_copy nesta instância vazio. O objeto a ser copiado é passado como um argumento, para este &amp;ldquo;Construtor
de cópias&amp;rdquo;, podendo inicializar a cópia. Para exemplo, o método initialize_copy pode copiar recursivamente os dados internos de um objeto
para que o objeto resultante, não sendo uma simples cópia superficial do original.&lt;/p&gt;

&lt;p&gt;Classes também podem substituir os métodos clone e dup diretamente para produzir qualquer tipo de copia que eles desejam.&lt;/p&gt;

&lt;p&gt;Há duas diferenças importantes entre os métodos clone e dup definidos pelo objeto. Primeiro, as cópias do clone tanto o congelado e
quanto o estado contaminado(definido em breve) de um objeto, enquanto dup apenas copia o estado contaminado, chamando dup sobre um objeto
congelado retorna uma cópia descongelada. Em segundo lugar, clone cópia quaisquer métodos singleton do objeto, enquanto que dup não.&lt;/p&gt;

&lt;h3&gt;Objetos Empacotamento&lt;/h3&gt;

&lt;p&gt;Você pode salvar o estado de um objeto passando para a classe &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/Marshal.html&#34;&gt;Marshal&lt;/a&gt;, com o método &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-dump&#34;&gt;dump&lt;/a&gt;. Se você passar um objeto de fluxo de I/O como o segundo argumento, escreve o estado do objeto Marshal.dump (e, de forma recursiva, quaisquer objetos que referencia) para esse fluxo.
Caso contrário, ele simplesmente retorna o estado codificado como uma string binária.&lt;/p&gt;

&lt;p&gt;Para restaurar um objeto empacotado, passe uma string ou um fluxo de contendo I/O do objeto de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-load&#34;&gt;Marshal.load&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O empacotamento de um objeto é uma maneira muito simples para salvar seu estado para uma utilização posterior, e estes métodos podem ser
usados ​​para fornecer um arquivo automático no formato de programas Ruby. Note, no entanto, que o formato binário usado por &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-dump&#34;&gt;Marshal.dump&lt;/a&gt; e &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-load&#34;&gt;Marshal.load&lt;/a&gt; é dependente da versão, e nas mais recentes versões do Ruby não são garantidos para ser capaz de ler
objetos empacotados escritos por versões mais antigas do Ruby.&lt;/p&gt;

&lt;p&gt;Outro uso para Marshal.dump e Marshal.load é criar cópias de profundidade de objetos:&lt;/p&gt;

&lt;p&gt;```ruby Marshal
def deepcopy(o)
  Marshal.load (Marshal.dump (o))
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Note que os arquivos de fluxo I/O, bem como o método e os objetos Binding, são dinâmicos demais para ser empacotado, não haveria nenhuma
maneira confiável para restaurar seu Estado.

YAML (&amp;quot;YAML não é Markup Language&amp;quot;) é uma alternativa comumente utilizada para o módulo Marshal que depósita objetos (e carrega objetos) a
partir de um texto com formato legível. É na biblioteca padrão, e você deve exigir usá-lo &#39;yaml&#39;.

&amp;lt;h3&amp;gt;Objetos de congelamento&amp;lt;/h3&amp;gt;

Qualquer objeto pode ser congelado chamando seu método de freeze. A objeto congelado torna imutável e nenhum de seu estado interno pode
ser mudado, e uma tentativa de chamar qualquer um dos seus métodos de falha de modificadores:


```ruby  Freeze
s = &amp;quot;gelo&amp;quot; # String são objetos mutáveis
s.freeze # Faça desta cadeia imutável
s.frozen? # Verdade: ele foi congelado
s.upcase! # TypeError: não pode modificar cadeia de congelados
s[0] = &amp;quot;ni&amp;quot; # TypeError: não pode modificar cadeia de congelados
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Congelar um objeto de classe impede a adição de quaisquer métodos para essa classe.&lt;/p&gt;

&lt;p&gt;Você pode verificar se um objeto é congelado com o método frozen?. Uma vez congelado, não há maneira para &amp;ldquo;descongelar&amp;rdquo; um objeto. Se
você copiar um objeto congelado com clone, a cópia também será congelada. Se você copiar um objeto congelado com dup, no entanto, a
cópia não será congelada.&lt;/p&gt;

&lt;h3&gt;Objetos contaminados e não confiáveis&lt;/h3&gt;

&lt;p&gt;Aplicações Web deve muitas vezes acompanhar de dados de entrada, derivados de não confiáveis do usuário para evitar ataques de injeção
de SQL e riscos de segurança semelhantes. Ruby oferece uma solução simples para esse problema: qualquer objeto pode ser marcado como
contaminado, chamando seu método taint. Depois que um objeto está contaminado, qualquer objetos derivado, também será contaminado. O
taint de um objeto pode ser testado com o método tainted? método:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby taint
s = &amp;quot;não confiáveis&amp;quot; # Os objetos são normalmente não viciada
s.taint # Marcar como não confiável objeto contaminado
s.tainted? # Verdade: ele está contaminado
s.upcase.tainted? # Verdade: objetos derivados estão contaminados
s[3,4].tainted? # Verdade: substrings estão contaminados
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;De entrada, tais como usuário de linha de comando argumentos, ambiente de variáveis, e seqüências de leitura com gets, são automaticamente
contaminados. Quando a variavel global $SAFE é definida com um valor maior que zero, Ruby restringe vários métodos embutidos que eles não
vão trabalhar com dados adulterados. Cópias de objetos contaminados feitos com clone e dup permanecem contaminados. Um objeto contaminado
pode ser descontaminado com o método untaint. Você só deve fazer isso, claro, se você examinar o objeto e está convencido de que não apresenta riscos de segurança.&lt;/p&gt;

&lt;p&gt;Em Ruby 1.9, os objectos podem não ser confiável para além de ser manchado. Os métodos untrusted?, untrust, e trust verificam e definem a
lealdade de um objeto. Código não confiável cria objetos não confiáveis, objetos contaminados e não é permitido para modificar objetos
confiáveis.&lt;/p&gt;

&lt;p&gt;Boa noite amigos&amp;hellip; até a proxima..&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>classe objects em ruby 1 dot 9 2</title>
      <link>http://rodij.me/post/2012/05/19/classe-objects-em-ruby-1-dot-9-2/</link>
      <pubDate>Sat, 19 May 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/05/19/classe-objects-em-ruby-1-dot-9-2/</guid>
      <description>&lt;p&gt;Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language&lt;/p&gt;

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Object.html&#34;&gt;Objects&lt;/a&gt;, é hora de nos aprofundar.&lt;/p&gt;

&lt;h1&gt;Objetos&lt;/h1&gt;

&lt;p&gt;Ruby é uma forma muito pura de linguagem orientada a objetos: todos os valores são
objetos, e não há distinção entre tipos primitivos e tipos de objetos, como existem em muitos
outras línguas. Em Ruby, todos os objetos herdam de uma classe chamada
&lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Object.html&#34;&gt;Object&lt;/a&gt; e compartilhar os métodos definidos
por essa classe. Esta seção explica as características comuns de todos os objetos
em Ruby. Teremos algumas partes para falar desta classe tão poderosa, mas é muito importante para o entendimento de OO em Ruby.&lt;/p&gt;

&lt;h3&gt;Referências de objeto&lt;/h3&gt;

&lt;p&gt;Quando trabalhamos com objetos em Ruby, realmente estamos trabalhando com referências a objetos. Não é o
próprio objeto que manipula, mas uma referência a ele&lt;a href=&#34;{{ root_url }}/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2/#referencia&#34;&gt;[*]&lt;/a&gt;.
Quando atribuir um valor a uma variável, não estamos copiando um objeto &amp;ldquo;em&amp;rdquo; variável que, nós
São apenas armazenar uma referência a um objeto para essa variável. Alguns
código deixa isso claro:&lt;/p&gt;

&lt;p&gt;``` ruby Objects
s = &amp;ldquo;Ruby&amp;rdquo; # Criar um objeto String. Armazenar uma referência a ele em s.
t = s # Copiar a referência a t. s e t referem-se ambos para o mesmo objeto.
t[-1] = &amp;ldquo;&amp;rdquo; # Modificar o objeto através da referência t.
print s # Acesse o objeto modificado através de s. Prints &amp;ldquo;Esfregue&amp;rdquo;.
t = &amp;ldquo;Java&amp;rdquo; # t agora se refere a um objeto diferente.
print s, t # Imprime &amp;ldquo;RubJava&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Quando você passar um objeto para um método em Ruby, é um objeto
referência que é passado para o método. Não é o objeto em si,
e não é uma referência para a referência ao objecto. Outra forma
dizer isso é que os argumentos do método são passados ​​por
valor e não por referência, mas
que os valores passados ​​são referências de objeto.

Porque as referências de objeto são passados ​​para os métodos, os métodos podem usar
essas referências para modificar o objeto subjacente. Essas modificações
são, então, visível quando o método retorna.

&amp;lt;h3&amp;gt;Valores imediatos&amp;lt;/h3&amp;gt;

Nós dissemos que todos os valores em Ruby são objetos e todos os objetos
são manipulados por referência. Na implementação de referência, no entanto objetos Fixnum e Symbol são realmente &amp;quot;valores imediatos&amp;quot;,
em vez de referências. Nenhuma destas duas classes tem métodos diferenciados, de modo que os
Objetos Fixnum e símbolo são imutáveis, o que significa que não há realmente nenhuma maneira de dizer que eles são manipulados por
valor, e não pela existência de valores de referencia.

A existência de valores imediatos deve ser considerado um detalhe de implementação. A única diferença prática entre
valores imediatos e valores de referência é que os valores imediatos
não pode ter métodos singleton definidas sobre eles.

&amp;lt;h3&amp;gt;Vida útil de objeto&amp;lt;/h3&amp;gt;

As classes internas em Ruby descritas neste capítulo têm sintaxes literal e instâncias dessas classes são criadas simplesmente por
inclusão de valores literalmente em seu código. Objetos de outras classes precisam ser explicitamente criados,
e isso é feito na maioria das vezes com um método chamado de new:

``` ruby Class.new
myObject = MyClass.New
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new é um método do Classe Class. Atribui na memória para manter o objeto new, então ele inicializa o estado do
recém alocados objetos &amp;ldquo;vazio&amp;rdquo;, invocando seu método initialize. Os argumentos para new são passadas diretamente para inicializar.
A maioria das classes definem um método initialize para executar qualquer inicialização, sendo necessário para instâncias.&lt;/p&gt;

&lt;p&gt;Os métodos new e initialize fornecer o padrão técnico para a criação de novas classes, mas classes também podem definir outros
métodos, conhecidos como &amp;ldquo;métodos de fábrica&amp;rdquo;, que retornam instâncias.&lt;/p&gt;

&lt;p&gt;Objetos Ruby não precisa ser desalocada explicitamente, como o fazem as linguagens C, C++, entre outras. Ruby usa uma técnica chamada
&lt;a href=&#34;http://www.rubyinside.com.br/como-o-ruby-gerencia-memoria-e-faz-garbage-collection-3018&#34;&gt;garbage collection&lt;/a&gt; (coleta de lixo) automaticamente, para destruir objetos que não são mais necessários. Um objeto se torna um candidato para o garbage collection quando é
inacessível, quando não há referências restantes para o objeto com exceção de outros objetos inacessíveis.&lt;/p&gt;

&lt;p&gt;O fato de que Ruby usa garbage collection, isso significa que programas em Ruby são menos suscetíveis a vazamentos de memória
que os programas escritos em linguagems que requerem objetos e memória para ser desalocada explicitamente e liberado.
Mas o garbage collection não significa que vazamentos de memória são impossíveis:
qualquer código que cria vida longa tem referências a objetos que de outro modo seria de curta duração pode ser uma fonte de
falhas de memória. Considere um hash usado como um cache. Se o cache não é podado usando algum tipo de algoritmo
menos utilizado recentemente, os objetos em cache permanecem acessíveis enquanto o hash em si é alcançável. Se o hash
é referenciado por uma variável global, então será acessível como desde que o interpretador Ruby está sendo executado.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;referencia&#34;&gt;&lt;/a&gt;
    [*] -&amp;gt; Se você está familiarizado com C ou C++, você pode pensar de uma
    referência como um ponteiro: o endereço do objeto na memória. Ruby
    não utiliza ponteiros, no entanto. Referências em Ruby são opacas e
    internas para a implementação. Não há maneira de tirar o
    tratamento de um valor não referenciado, um valor, ou fazer ponteiro aritmético.&lt;/p&gt;

&lt;p&gt;Um pouco de conceito de Objetos, logo teremos mais na pratica&amp;hellip;&lt;/p&gt;

&lt;p&gt;Até a proxima&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>classe objects em ruby 1 dot 9 2 part ii</title>
      <link>http://rodij.me/post/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-ii/</link>
      <pubDate>Sat, 19 May 2012 00:00:00 UTC</pubDate>
      
      <guid>http://rodij.me/post/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-ii/</guid>
      <description>

&lt;p&gt;Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language&lt;/p&gt;

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Object.html&#34;&gt;Objects&lt;/a&gt;, é hora de nos aprofundar.&lt;/p&gt;

&lt;h1&gt;Objetos&lt;/h1&gt;

&lt;h3&gt;Identidade do objeto&lt;/h3&gt;

&lt;p&gt;Cada objeto tem um identificador de objeto, um Fixnum, que você pode obter com o método object_id. O valor retornado por este
método é constante e exclusivo para a vida útil do objeto. Enquanto o objeto é acessível, ele terá sempre a mesma identificação, e não
outro objeto que irá partilhar do mesmo ID.&lt;/p&gt;

&lt;p&gt;O ID de método é um sinônimo preterido para object_id. Ruby 1.8 emite um aviso se você usá-lo, e ele foi removido em
Ruby 1.9.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;id&lt;/strong&gt; é um sinônimo válido para object_id. Ele existe como um retorno, assim você pode acessar ID de um objeto, mesmo se o método
object_id foi indefinido ou substituído.&lt;/p&gt;

&lt;p&gt;A classe &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Object.html&#34;&gt;Object&lt;/a&gt; implementa o método de hash para simplesmente retornar um
ID objeto.&lt;/p&gt;

&lt;h3&gt;Classe de Objeto e Tipo de Objeto&lt;/h3&gt;

&lt;p&gt;Existem várias maneiras de determinar a classe de um objeto em Ruby. O mais simples é simplesmente perguntar para ele:&lt;/p&gt;

&lt;p&gt;``` ruby Class
o = &amp;ldquo;teste&amp;rdquo; # Este é um valor
o.class # Retorna um objeto que representa a classe String&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Se você estiver interessado na hierarquia de classe de um objeto, você pode perguntar para qualquer classe qual é sua superclasse:

``` ruby Class - Ruby 1.8
o.class # String: o é um objeto String
o.class.superclass # Object: superclasse de String é objeto
o.class.superclass.superclass # nil: Object não tem superclasse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No Ruby 1.9, Object já não é a verdadeira raiz da hierarquia de classes:&lt;/p&gt;

&lt;p&gt;``` ruby Class - Ruby 1.9&lt;/p&gt;

&lt;h1 id=&#34;ruby-1-9&#34;&gt;Ruby 1.9&lt;/h1&gt;

&lt;p&gt;Object.superclass # BasicObject: Object tem uma superclasse em 1.9
BasicObject.superclass # nil: BasicObject não tem nenhuma superclasse&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Assim, uma forma particularmente simples para verificar a classe de um objeto é, por comparação direta:

``` ruby Class
o.class == String # true se o é uma String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O método instance_of? faz a mesma coisa e é um pouco mais elegante:&lt;/p&gt;

&lt;p&gt;``` ruby Class
o.instance_of? String # verdade se o é uma String&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Normalmente, quando testamos a classe de um objeto, também gostaríamos saber se o objeto é uma instância de qualquer subclasse
dessa classe. Para testar isso, use o método is_a?, ou seu sinônimo kind_of?

```ruby Class
x = 1 # Este é o valor que estamos trabalhando com
x.instance_of? Fixnum # verdade: é uma instância de Fixnum
x.instance_of? Numeric # false: instance_of? não verifica a herança
x.is_a? Fixnum # verdadeiro: x é um Fixnum
x.is_a? Integer # verdade: x é um número inteiro
x.is_a? Numeric # verdade: x é um numérico
x.is_a? Comparable # verdade: funciona também com módulos mixin
x.is_a? Object # verdadeira para qualquer valor de x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A classe Class define o operador === em tal modo que ele pode ser usado no lugar do is_a?:&lt;/p&gt;

&lt;p&gt;``` ruby Class method ===
Numeric === x # verdade: x is_a Numérico&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Essa expressão é exclusivo para Ruby e é, provavelmente, menos legível do que utilizando o mais tradicional método is_a?.

Cada objeto tem uma classe bem definida em Ruby, e que a classe nunca muda durante a vida útil do objeto. Um objeto
type, por outro lado, é mais fluido. O tipo de um objeto está relacionada à sua classe, mas a classe é apenas parte de um
tipo de objeto. Quando falamos sobre o tipo de um objeto, nós entendemos o conjunto de comportamentos que caracterizam o objeto.
Outra maneira é colocar o tipo de um objeto em um conjunto de métodos que podem responder.
(Esta definição torna-se recursiva, porque não é apenas o nome dos métodos que importam, mas também os tipos de argumentos que os
métodos podem aceitar.)

Na programação com Ruby, que muitas vezes não se preocupam com a classe de um objeto, nós só queremos saber se podemos invocar
algum método nele.  Considere-se, por exemplo, o operador &amp;lt;&amp;lt;. Arrays, strings, files e outros I/O relacionados ao definir as classes
isso como um operador de acréscimo. Se estamos escrevendo um método que produz produção textual, podemos escrever, genericamente,
a usar esse operador. Então, o nosso método pode ser invocado com qualquer argumento que implementa &amp;lt;&amp;lt;. Nós não nos importamos com a
classe do argumento, basta que possamos anexá-lo. Nós podemos testar para isto com o método respond_to? :

```ruby Class respond_to?
o.respond_to? :&amp;quot;&amp;lt;&amp;lt;&amp;quot; # Verdadeiro se o operador tem uma &amp;lt;&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A deficiência desta abordagem é que ela só verifica o nome de um método, não os argumentos para esse método. Por exemplo,
Fixnum e Bignum implementam &amp;lt;&amp;lt; como um operador de deslocamento à esquerda e espera o argumento de ser um número em vez de uma string.
Objetos inteiros parecem ser &amp;ldquo;appendable&amp;rdquo; (adicionável) quando usamos um respond_to? de teste, mas que produzem um erro quando
adiciona um código em string. Não há uma solução geral para este problema, mas um recurso ad-hoc, neste caso,
é explicitamente excluir objectos numéricos com o método is_a? :&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Class
o.respond_to? :&amp;quot;&amp;lt;&amp;lt;&amp;quot; and not o.is_a? Numeric
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Outro exemplo do tipo distinção-versus-classe é a classe StringIO&lt;a href=&#34;partir da Biblioteca padrão do Ruby&#34;&gt;*&lt;/a&gt;. StringIO permite a
leitura e gravação das strings como se fossem Objetos de IO. StringIO[*] imita os objetos IO API-StringIO definem os mesmos métodos
que os objetos IO fazem. Mas StringIO não é uma subclasse de IO. Se você escrever um método que espera um argumento de fluxo,
e testa a classe do argumento com is_a? IO, em seguida, o método não funciona com argumentos StringIO.&lt;/p&gt;

&lt;p&gt;[*] -&amp;gt; &lt;a href=&#34;http://www.ruby-doc.org/stdlib-1.9.3/libdoc/stringio/rdoc/StringIO.html&#34;&gt;StringIO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;É isso ai rubistas&amp;hellip; A cada vez que leio sobre, me apaixono mais. :D&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
