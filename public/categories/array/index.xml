<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Array on Rodrigo Martins </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>https://limitless-eyrie-46143.herokuapp.com/categories/array/</link>
    <language>en-us</language>
    
    <copyright>I&#39;m a Catholic Christian, software developer, Passionate about life, codes, questions, theories and theorems. :)</copyright>
    <updated>Wed, 29 Aug 2012 00:00:00 UTC</updated>
    
    <item>
      <title>reflexao e metaprogramacao number ruby 1 dot 9 part ii</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/08/29/reflexao-e-metaprogramacao-number-ruby-1-dot-9-part-ii/</link>
      <pubDate>Wed, 29 Aug 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/08/29/reflexao-e-metaprogramacao-number-ruby-1-dot-9-part-ii/</guid>
      <description>

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de continuar nos aprofundando um pouco mais de
&lt;b&gt;Reflexão e Metaprogramação&lt;/b&gt; agora &lt;b&gt;Avaliando Strings e Blocos&lt;/b&gt;... Estranho para alguns, mas, veremos que é simples!&lt;/p&gt;

&lt;h1&gt;Avaliando Strings e Blocos&lt;/h1&gt;

&lt;p&gt;Um dos mais poderosos reflexivos e de características direta do Ruby, é seu método &lt;code&gt;eval&lt;/code&gt;. Se o seu programa Ruby pode gerar uma seqüência de código
válido Ruby, o método &lt;code&gt;Kernel.eval&lt;/code&gt; pode avaliar que o código:&lt;/p&gt;

&lt;p&gt;``` ruby Kernel.eval
x = 1
eval &amp;ldquo;x + 1&amp;rdquo;  # =&amp;gt; 2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
`eval` é uma função poderosa, mas ao menos que você realmente está escrevendo um programa `shell` (como irb) que executa as linhas de códigos Ruby
inserido por um usuário é improvável que você realmente precisa. (E em um contexto de rede, quase nunca é seguro para chamar `eval` no texto recebido
de um usuário, que podia conter um código malicioso). Programadores inexperientes, por vezes, acabam usando eval como uma muleta. Se você tiver que
usá-lo em seu código, ver se não há uma maneira de evitá-lo. Dito isto, há algumas maneiras mais úteis para usar métodos `eval` e `eval-like`.

&amp;lt;h3&amp;gt;Associações e eval&amp;lt;/h3&amp;gt;

Um objeto de Associação, representa o estado de variáveis `bindings` de Ruby em algum momento. O objeto `Kernel.binding` retorna as ligações em vigor
no local da chamada. Você pode passar um objeto de associação como o segundo argumento para `eval`, e a `String` especificada será avaliada no
contexto dessas ligações. Se, por exemplo, definir um método de instância que retorna um objeto `Binding` que representa a variável de ligações
dentro de um objeto, então nós podemos usar essas ligações para consultar e definir as variáveis de instância do objeto. Podemos conseguir isso como segue:

``` ruby Binding
class Object # Abre objeto para adicionar um novo método
  def bindings # Nota plural sobre este método
    binding # Este é o método de Kernel predefinido
  end
end

class Test # Uma classe simples com uma variável de instância
  def initialize(s); @x = s; end
end

t = Test.new(10) # Criar um objeto test
eval(&amp;quot;@x&amp;quot;, t.bindings)  # =&amp;gt; 10: Espia dentro t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note que não é realmente necessário definir um método de &lt;code&gt;Object.bindings&lt;/code&gt; deste tipo para observar nas variáveis de instância de um objeto. Vários
outros métodos descritos logo oferecem maneiras mais fáceis de consulta (e de conjunto) do valor das variáveis de instância de um objeto.&lt;/p&gt;

&lt;p&gt;Os objetos &lt;code&gt;Proc&lt;/code&gt; definem um método público de ligação que retorna uma Associação de objeto que representa a variável ligação em vigor para o corpo
do &lt;code&gt;Proc&lt;/code&gt;. Além disso, o método &lt;code&gt;eval&lt;/code&gt; permite que você passe um objeto &lt;code&gt;Proc&lt;/code&gt; em vez de um objeto de associação como o segundo argumento.&lt;/p&gt;

&lt;p&gt;Ruby 1.9 define um método &lt;code&gt;eval&lt;/code&gt; em objetos de associação, de modo em vez de passar uma associação como o segundo argumento para o &lt;code&gt;eval&lt;/code&gt; global,
você pode, em vez de invocar o método &lt;code&gt;eval&lt;/code&gt; em uma ligação. Qual você escolhe é puramente uma questão de estética, as duas técnicas são equivalentes.&lt;/p&gt;

&lt;h3&gt;instance_eval e class_eval&lt;/h3&gt;

&lt;p&gt;A classe &lt;code&gt;Object&lt;/code&gt; define um método chamado &lt;code&gt;instance_eval&lt;/code&gt;, e a classe &lt;code&gt;Module&lt;/code&gt; define um método chamado &lt;code&gt;class_eval&lt;/code&gt;. &lt;code&gt;module_eval&lt;/code&gt; é um sinônimo
para &lt;code&gt;class_eval&lt;/code&gt;. Ambos os métodos avaliam código Ruby, como o &lt;code&gt;eval&lt;/code&gt; faz, mas existem duas diferenças importantes. A primeira diferença é a que eles
avaliam o código no contexto do objecto específico ou no contexto especificado de cada módulo do objecto ou é o valor enquanto o código está sendo
avaliado. Aqui estão alguns exemplos:&lt;/p&gt;

&lt;p&gt;``` ruby instance_eval e class_eval
o.instance_eval(&amp;ldquo;@x&amp;rdquo;)  # Retorna o valor da variável de instância o @x&lt;/p&gt;

&lt;h1 id=&#34;define-um-len-método-de-instância-de-string-para-retornar-comprimento-da-string&#34;&gt;Define um len método de instância de String para retornar comprimento da String&lt;/h1&gt;

&lt;p&gt;String.class_eval(&amp;ldquo;def len; size; end&amp;rdquo;)&lt;/p&gt;

&lt;h1 id=&#34;aqui-está-outra-maneira-de-fazer-isso&#34;&gt;Aqui está outra maneira de fazer isso&lt;/h1&gt;

&lt;h1 id=&#34;o-código-citado-se-comporta-como-se-fosse-dentro-da-class-string-e-end&#34;&gt;O código citado se comporta como se fosse dentro da &amp;ldquo;class String&amp;rdquo; e &amp;ldquo;end&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;String.class_eval(&amp;ldquo;alias len size&amp;rdquo;)&lt;/p&gt;

&lt;h1 id=&#34;use-instance-eval-para-definir-método-de-classe-string-empty&#34;&gt;Use instance_eval para definir método de classe String.Empty&lt;/h1&gt;

&lt;h1 id=&#34;note-que-as-aspas-dentro-da-aspas-fica-um-pouco-complicado&#34;&gt;Note que as aspas dentro da aspas fica um pouco complicado &amp;hellip;&lt;/h1&gt;

&lt;p&gt;String.instance_eval (&amp;ldquo;def vazio;&amp;rdquo;; fim&amp;rdquo;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Observe a diferença sutil, mas crucial entre `instance_eval` e `class_eval` quando o código que está sendo avaliado contém uma definição de método.
`instance_eval` define métodos únicos do objeto (e isso resulta em métodos de classe quando for chamado em uma classe de objeto). `class_eval` define métodos de instância regulare.

A segunda diferença importante entre estes dois métodos e o eval global é que `instance_eval` e `class_eval` pode aceitar um bloco de código para
avaliar. Quando passa um bloco em vez de uma `String`, o código do bloco é executado no contexto apropriado. Aqui, por conseguinte, são alternativas
para as invocações anteriorment mostrada:

``` ruby instance_eval e class_eval
o.instance_eval { @x }
String.class_eval {
  def len
    size
  end
}
String.class_eval { alias len size }
String.instance_eval { def empty; &amp;quot;&amp;quot;; end }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;instance_exec e class_exec&lt;/h3&gt;

&lt;p&gt;Ruby 1.9 define dois métodos de avaliação a mais: &lt;code&gt;instance_exec&lt;/code&gt; e &lt;code&gt;class_exec&lt;/code&gt; (e seu alias, &lt;code&gt;module_exec&lt;/code&gt;). Estes métodos de avaliação de um bloco
(Mas não uma cadeia) de código, no contexto do objeto receptor, como fazem &lt;code&gt;instance_eval&lt;/code&gt; e &lt;code&gt;class_eval&lt;/code&gt;. A diferença é que o métodos &lt;code&gt;exec&lt;/code&gt; aceita
argumentos e passá para o bloco. Assim, o bloco do código é avaliado no contexto de um objeto determinado, com parâmetros cujos valores vêm a partir
do exterior do objecto.&lt;/p&gt;

&lt;p&gt;Até o proximo post amigos! :P&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>reflexao e metaprogramacao number ruby 1 dot 9</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/08/26/reflexao-e-metaprogramacao-number-ruby-1-dot-9/</link>
      <pubDate>Sun, 26 Aug 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/08/26/reflexao-e-metaprogramacao-number-ruby-1-dot-9/</guid>
      <description>

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de &lt;b&gt;Reflexão e Metaprogramação&lt;/b&gt;... Estranho para alguns, mas, veremos que é simples!&lt;/p&gt;

&lt;h1&gt;Reflexão e Metaprogramação&lt;/h1&gt;

&lt;p&gt;Vimos que Ruby é uma linguagem muito dinâmica, você pode inserir novos métodos em classes em tempo de execução, criar apelidos
para métodos existentes, e até mesmo definir métodos em objetos individuais. Além disso, ele tem uma rica API para a reflexão.
Reflexão, também chamado de introspecção, significa simplesmente que um programa pode examinar seu estado e sua estrutura. Um
programa Ruby pode, por exemplo, obter a lista de métodos definidos pela classe &lt;code&gt;Hash&lt;/code&gt;, consultar o valor de uma variável de
instância nomeada dentro de um objeto especificado, ou percorrer todos os objetos &lt;code&gt;Regexp&lt;/code&gt; atualmente definidos pelo intérprete.
A API de reflexão, na verdade, vai além e permite que um programa para alterar o seu estado e estrutura. Um programa Ruby pode
definir dinamicamente variáveis chamadas, invocar métodos nomeados, e até mesmo definir novas classes e novos métodos.&lt;/p&gt;

&lt;p&gt;API Reflexão Ruby, juntamente com a sua natureza geral, dinâmica, seu controle de estrutura de blocos iteradores, e a sintaxe
dos seus parênteses opcionais sintaxe torna uma linguagem ideal para metaprogramação. Vagamente definida, metaprogramação está
escrevendo programas (ou frameworks) que ajudam a escrever programas. Para colocar de outra forma, a metaprogramação é um
conjunto de técnicas para estender a sintaxe de Ruby de uma forma que facilita a programação. Metaprogramação está intimamente
ligada à idéia de escrever linguagens específicas de domínio, ou &lt;code&gt;DSL&#39;s&lt;/code&gt;. &lt;code&gt;DSL&#39;s&lt;/code&gt; em Ruby normalmente usam invocações de métodos e
blocos, como se fossem palavras-chave em uma extensão de tarefas específicas para a linguagem.&lt;/p&gt;

&lt;p&gt;Neste post começo com várias seções que introduzem a API de reflexão do Ruby. Esta API é surpreendentemente rica e consiste de
poucos métodos. Estes métodos são definidos, para a maior parte, pelo &lt;code&gt;Kernel&lt;/code&gt;, &lt;code&gt;Module&lt;/code&gt; e &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Enquanto você lê estas seções introdutórias, tenha em mente que reflexão não é, por si só, a metaprogramação. Metaprogramação
tipicamente estende a sintaxe ou o comportamento de Ruby, de alguma forma, e com frequência envolve mais do que um tipo de
reflexão. Depois de introduzir a reflexão o núcleo da API de Ruby, neste post demonstrarei, por exemplo, técnicas comuns de
metaprogramação que usam essa API.&lt;/p&gt;

&lt;p&gt;Note-se que este post aborda tópicos avançados. Você pode ser um programador Ruby produtivo sem nunca ler este post. Você pode
encontrar que é útil para ler os próximos post&amp;rsquo;s deste primeiro livro, e depois retornar a este capítulo. Considere este
post uma espécie de exame final: se você entender os exemplos (especialmente os mais queridos no final), então você domina Ruby!&lt;/p&gt;

&lt;h3&gt;Tipos, classes e módulos&lt;/h3&gt;

&lt;p&gt;Os métodos mais utilizados são aqueles mais reflexivos para determinar o tipo de um objeto que classe é uma instância e quais
métodos ele responde. Para rever:&lt;/p&gt;

&lt;p&gt;``` ruby Metaprogramming
o.class&lt;/p&gt;

&lt;h1 id=&#34;retorna-a-classe-de-do-objeto-o&#34;&gt;Retorna a classe de do objeto &amp;lsquo;o&amp;rsquo;.&lt;/h1&gt;

&lt;p&gt;c.superclass&lt;/p&gt;

&lt;h1 id=&#34;retorna-a-superclasse-de-uma-classe-c&#34;&gt;Retorna a superclasse de uma classe &amp;lsquo;c&amp;rsquo;.&lt;/h1&gt;

&lt;p&gt;o.instance_of? c&lt;/p&gt;

&lt;h1 id=&#34;determina-se-o-objeto-o-class-c&#34;&gt;Determina se o objeto &amp;lsquo;o.class == c&amp;rsquo;.&lt;/h1&gt;

&lt;p&gt;o.is_a? c&lt;/p&gt;

&lt;h1 id=&#34;determina-se-o-é-um-exemplo-de-c-ou-de-qualquer-das-suas-subclasses-se-c-for-um-módulo-este-método-testa-se-o-class-ou-qualquer-um-de-seus-ancestrais-inclui-o-módulo&#34;&gt;Determina se &amp;lsquo;o&amp;rsquo; é um exemplo de &amp;lsquo;c&amp;rsquo;, ou de qualquer das suas subclasses. Se &amp;lsquo;c&amp;rsquo; for um módulo, este método testa se &amp;lsquo;o.class&amp;rsquo; (ou qualquer um de seus ancestrais) inclui o módulo.&lt;/h1&gt;

&lt;p&gt;o.kind_of? c&lt;/p&gt;

&lt;h1 id=&#34;kind-of-é-um-sinônimo-para-is-a&#34;&gt;kind_of? é um sinônimo para is_a?.&lt;/h1&gt;

&lt;p&gt;c === o&lt;/p&gt;

&lt;h1 id=&#34;para-qualquer-classe-c-ou-módulo-determina-se-o-is-a-c&#34;&gt;Para qualquer classe &amp;lsquo;c&amp;rsquo; ou módulo, determina se &amp;lsquo;o.is_a? &amp;copy;&amp;rsquo;&lt;/h1&gt;

&lt;p&gt;o.respond_to? nome&lt;/p&gt;

&lt;h1 id=&#34;determina-se-o-objeto-o-tem-um-método-público-ou-protegido-com-o-nome-especificado-passar-true-como-o-segundo-argumento-para-verificar-métodos-privados-também&#34;&gt;Determina se o objeto &amp;lsquo;o&amp;rsquo; tem um método público ou protegido com o nome especificado. Passar true como o segundo argumento para verificar métodos privados, também.&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;h3&amp;gt;Ancestralidade e Módulos&amp;lt;/h3&amp;gt;

Além desses métodos que você já viu, há mais alguns métodos relacionados reflexivos para determinar os ancestrais de uma
classe ou módulo e para determinar quais os módulos que são incluídos por uma classe ou módulo. Esses métodos são fáceis de
entender quando demonstrado:

``` ruby Alguns demonstrações
module A; end                # Modulo vazio
module B; include A; end;    # Módulo B inclui A
class C; include B; end;     # Classe C inclui o módulo B

C &amp;lt; B                # =&amp;gt; true: C inclui B
B &amp;lt; A                # =&amp;gt; true: B inclui A
C &amp;lt; A                # =&amp;gt; true
Fixnum &amp;lt; Integer     # =&amp;gt; true: todos os fixnums são inteiros
Integer &amp;lt; Comparable # =&amp;gt; true: inteiros são comparáveis
Integer &amp;lt; Fixnum     # =&amp;gt; false: nem todos os números inteiros são fixnums
String &amp;lt; Numeric     # =&amp;gt; nil: cordas não são números

A.ancestors          # =&amp;gt; [A]
B.ancestors          # =&amp;gt; [B, A]
C.ancestors          # =&amp;gt; [C, B, A, Object, Kernel]
String.ancestors     # =&amp;gt; [String, Enumerable, Comparable, Object, Kernel]
                     # Nota: em Ruby 1.9, String não é mais Enumerable

C.include?(B) # =&amp;gt; true
C.include?(A) # =&amp;gt; true
B.include?(A) # =&amp;gt; true
A.include?(A) # =&amp;gt; false
A.include?(B) # =&amp;gt; false

A.included_modules # =&amp;gt; []
B.included_modules # =&amp;gt; [A]
C.included_modules # =&amp;gt; [B, A, Kernel]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este código demonstra &lt;code&gt;include?&lt;/code&gt;, que é um método público de instância definido pela classe &lt;code&gt;Module&lt;/code&gt;. Mas ele também possui duas
invocações do método &lt;code&gt;include&lt;/code&gt; (Sem o sinal de interrogação), que é um método de instância particular de &lt;code&gt;Module&lt;/code&gt;. Como um
método particular, pode apenas ser chamado implicitamente em si, o que limita a sua utilização para o corpo de uma definição de
&lt;code&gt;class&lt;/code&gt; ou &lt;code&gt;module&lt;/code&gt;. Este uso do método &lt;code&gt;include&lt;/code&gt;, como se tratasse de uma palavra-chave, é um exemplo de metaprogramação no
núcleo da sintaxe de Ruby.&lt;/p&gt;

&lt;p&gt;Um método relacionado com o método &lt;code&gt;include&lt;/code&gt;, particular é o público &lt;code&gt;Object.extend&lt;/code&gt;. Este método estende um objeto por tornar
os métodos de instância de cada um dos módulos específicos em métodos &lt;code&gt;singleton&lt;/code&gt; do objeto:&lt;/p&gt;

&lt;p&gt;``` ruby Singleton
module Greeter; def hi; &amp;ldquo;hello&amp;rdquo;; end; end # módulo Greeter
s = &amp;ldquo;objeto de string&amp;rdquo;
s.extend(Greeter)       # Adicione &amp;ldquo;hello&amp;rdquo; como um método singleton para s
s.hi
String.extend(Greeter)  # Adicione &amp;ldquo;hello&amp;rdquo; como método de classe de String
String.hi               # =&amp;gt; &amp;ldquo;hello&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
O método `Module.nesting` de classe não está relacionado com a inclusão do módulo ou ascendência, em vez disso, ele retorna um
`array` que especifica o assentamento de módulos da localização atual. `Module.nesting[0]` é a classe atual ou módulo, `Module.nesting[1]` é o quem contém a `class` ou `module` e assim por diante:

```ruby Module e Class
module M
  class C
    Module.nesting   # =&amp;gt; [M::C, M]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Definindo Classes e Módulos&lt;/h3&gt;

&lt;p&gt;Classes e módulos são instâncias das classes de &lt;code&gt;Class&lt;/code&gt; e &lt;code&gt;Module&lt;/code&gt;. Como tal, você pode criá-los dinamicamente:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Class e Module dinamicamente
M = Module.new      # Define um novo módulo M
C = Class.new       # Define uma nova classe C
D = Class.new(C) {  # Definir uma subclasse de C
  include M         # inclui o módulo M
}
D.to_s              # =&amp;gt; &amp;quot;D&amp;quot;: classe recebe o nome da constante por magia
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Um recurso interessante do Ruby é que, quando um criado dinamicamente um módulo anónimo ou classe é atribuído a uma constante,
o nome dessa constante é usado como o nome do módulo ou classe (e é retornado pelo seu nome e método to_s).&lt;/p&gt;

&lt;p&gt;É isso ai amigos&amp;hellip;
Hora de dar um &lt;code&gt;break&lt;/code&gt;&amp;hellip; :)&lt;/p&gt;

&lt;p&gt;Até o proximo!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>blocos em number ruby 1 dot 9</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/08/19/blocos-em-number-ruby-1-dot-9/</link>
      <pubDate>Sun, 19 Aug 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/08/19/blocos-em-number-ruby-1-dot-9/</guid>
      <description>

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de `Blocks`... Estranho para alguns, mas, veremos que é simples!&lt;/p&gt;

&lt;h1&gt;Blocos em #Ruby 1.9&lt;/h1&gt;

&lt;p&gt;O uso de blocos é fundamental para o uso de iteradores. As subseções a seguir explicam:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A sintaxe para associar um bloco com uma invocação de método&lt;/li&gt;
&lt;li&gt;O &amp;ldquo;valor de retorno&amp;rdquo; de um bloco&lt;/li&gt;
&lt;li&gt;O escopo de variáveis ​​em blocos&lt;/li&gt;
&lt;li&gt;A diferença entre os parâmetros dos blocos e parâmetros de método&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Sintaxe bloco&lt;/h3&gt;

&lt;p&gt;Os &lt;code&gt;Blocos&lt;/code&gt; não podem ser autônomo, pois eles são apenas legal após uma chamada de método. Você pode, no entanto, colocar um
bloco depois de qualquer invocação método, se o método não é um iterador e nunca invoca o bloco com a produção, o bloco será
ignorado. Blocos são delimitados por chaves ou com palavras-chave &lt;code&gt;do/end&lt;/code&gt;. A abertura de chave ou a palavra-chave deve ser na
mesma linha com a invocação de método, ou então Ruby interpreta a linha como um terminador de instrução e invoca o método sem
o bloco:&lt;/p&gt;

&lt;p&gt;``` ruby Blocos&lt;/p&gt;

&lt;h1 id=&#34;imprima-os-números-1-a-10&#34;&gt;Imprima os números 1 a 10&lt;/h1&gt;

&lt;p&gt;1.upto(10) {|x| puts x } # Invocação e bloco em uma linha com aparelho
1.upto(10) do |x|        # Delimitado bloco com do/end
  puts x
end
1.upto(10)               # Bloco não especificado
  {|x| puts x }          # Erro na Sintaxe: bloco é permitido não depois de uma invocação&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Uma convenção comum é a utilização de chaves quando um bloco se encaixa em uma única linha, e para usar `do/end` quando o bloco
se estende sobre linhas.  Isso não é totalmente uma questão de convenção, no entanto, o analisador de Ruby liga firmemente
para o símbolo que precede. Se você omitir os parênteses em torno de argumentos de método e usar delimitadores de chaves para
um bloco, em seguida, o bloco vai ser associado com o último argumento do método em vez do método em si, o que não é,
provavelmente, o que deseja. Para evitar neste caso, coloque entre parênteses os argumentos ou delimite o bloco com `do` e
`end`:

``` ruby Blocks
1.upto(3) {|x| puts x} # Parens e encaracolado chaves trabalhar
1.upto 3 do |x| puts x end
1.upto 3 {|x| puts x} # erro de sintaxe: tentando passar um bloco para 3!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os blocos podem ser parametrizados, assim como métodos podem. Os parâmetros dos blocos são separados por vírgulas e delimitados
com um par de barra vertical (&lt;code&gt;|&lt;/code&gt;), mas eles são de outra maneira muito parecida com os parâmetros do método:&lt;/p&gt;

&lt;p&gt;```ruby Blocks&lt;/p&gt;

&lt;h1 id=&#34;o-iterador-hash-each-passa-dois-argumentos-para-seu-bloco&#34;&gt;O iterador Hash.each passa dois argumentos para seu bloco&lt;/h1&gt;

&lt;p&gt;hash.each do |chave, valor| # Para cada par (chave, valor) no hash
  puts &amp;ldquo;#{chave}: #{valor}&amp;rdquo; # Imprimir a chave eo valor
end # Fim do bloco&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
É uma convenção comum para escrever os parâmetros do bloco, na mesma linha, como a invocação do método e da chave de abertura
ou fazer palavra-chave, mas isto não é requerido pela sintaxe.


&amp;lt;h3&amp;gt;O Valor de um Bloco&amp;lt;/h3&amp;gt;

Considerando o método `Array.sort`. Se você associar um bloco com uma invocação deste método, ele irá produzir pares de
elementos para o bloco, e é o trabalho do bloco para classificá-los.

O valor do bloco de retorno `(-1, 0 ou 1)` indica a ordem dos dois argumentos. O &amp;quot;valor de retorno&amp;quot; do bloco está disponível
com o método `iterator` como o valor da declaração `yield`.

O &amp;quot;valor de retorno&amp;quot; de um bloco é simplesmente o valor da última expressão avaliada no bloco. Assim, para classificar um `array` de palavras maior de a menor, poderíamos escrever:

```ruby Metodo sort
# O bloco tem duas palavras e &amp;quot;retorna&amp;quot; a sua ordem relativa
words.sort! {| X, y | y.length &amp;lt;=&amp;gt; x.length}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nós estamos colocando a expressão &amp;ldquo;valor de retorno&amp;rdquo; entre aspas por uma razão muito importante: você não deve usar normalmente
a palavra-chave &lt;code&gt;return&lt;/code&gt; para retornar um bloco. Um &lt;code&gt;return&lt;/code&gt; dentro de um bloco faz com que o método que o contém (não o método
iterador que pertence ao bloco, mas o método que o bloco faz parte) o retorno naquela linha, o Ruby retorna a ultima linha do
bloco. Há, é claro, tem momentos em que isso é exatamente o que você quer fazer. Mas não use o &lt;code&gt;return&lt;/code&gt; se você quer apenas
voltar de um bloco para o método que chamou &lt;code&gt;yield&lt;/code&gt;. Se você precisar forçar um bloco para voltar ao método invocando antes que
ele atinja a última expressão, ou se você deseja retornar mais de um valor, você pode usar &lt;code&gt;next&lt;/code&gt; em vez de retorno. Aqui é um
exemplo que usa &lt;code&gt;next&lt;/code&gt; para voltar a partir do bloco:&lt;/p&gt;

&lt;p&gt;```ruby Usando next
array.collect do |x|
  next 0 if x == nil  # Retorna se x é nulo
  next x, x*x         # Retorna dois valores
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Note-se que não é particularmente comum usar `next` desta maneira, e o código acima é facilmente reescrito assim:

``` ruby Reescrevendo bloco
array.collect do |x|
  if x == nil
    0
  else
    [x, x*x]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Blocos e escopo de variáveis&lt;/h3&gt;

&lt;p&gt;Blocos que definem um novo escopo de variáveis: variáveis ​​criadas dentro de um bloco só existem dentro desse bloco e estão são
indefinidas fora do bloco. Seja cauteloso, no entanto, as variáveis ​​locais em um método estão disponíveis para todos os blocos
dentro desse método. Então, se um bloco atribui um valor a uma variável que já está definida fora do bloco, este não cria uma
variável local nova, mas em vez disso, atribui um novo valor para a variável já existente. Às vezes, isso é exatamente o
comportamento que queremos:&lt;/p&gt;

&lt;p&gt;``` ruby Escopos
total = 0
data.each {|x| total += x }  # Some os elementos da matriz de dados
puts total                   # Impressão do total da soma&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Às vezes, no entanto, nós não queremos alterar as variáveis ​​no escopo delimitador, mas fazemos acidentalmente. Este problema é
uma preocupação particular para os parâmetros dos blocos em Ruby 1.8. No Ruby 1.8, se um parâmetro do bloco compartilha o nome
de uma variável existente, então invocações do bloco simplesmente atribuir um valor a essa variável já existente em vez de
criar uma variável de bloco local novo. O seguinte código, por exemplo, é problemático porque utiliza o mesmo identificador `i`
como o parâmetro para dois blocos nested blocos:

``` ruby Usando mesma variavel, Ruby 1.8
1.upto(10) do |i|         # 10 linhas
  1.upto(10) do |i|       # Cada um tem 10 colunas
    print &amp;quot;#{i}&amp;quot;         # Imprimi o número de colunas
  end
  print &amp;quot; ==&amp;gt; Row #{i}\n&amp;quot; # Número de linhas
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruby 1.9 é diferente: os parâmetros dos blocos são sempre locais para o seu bloco, e invocações do bloco nunca atribuem valores
a variáveis ​​existentes. Se o Ruby 1.9 é invocado com o flag -w, ele irá avisá-lo se um parâmetro do bloco tem o mesmo nome de
uma variável existente. Isso ajuda a evitar escrever código que funciona de forma diferente em 1.8 e 1.9.&lt;/p&gt;

&lt;p&gt;Ruby 1.9 é diferente de outra maneira importante, também. Sintaxe do bloco foi estendida para permitir que você declare
variáveis de blocos locais ​​que são garantidas para ser local, mesmo se uma variável com o mesmo nome já existe no escopo
delimitador. Para fazer, siga a lista de parâmetros do bloco com um ponto e vírgula e uma lista separada por vírgulas de
variáveis ​​do bloco local. Aqui está um exemplo:&lt;/p&gt;

&lt;p&gt;``` ruby Variaveis
x = y = 0            # variáveis ​​locais
1.upto(4) do |x;y|   # x e y são locais para bloquear
                     # x e y são &amp;ldquo;sombra&amp;rdquo; das variáveis ​​externas
  y = x + 1          # Usa y como uma variável que vai receber valores
  puts y*y           # imprime 4, 9, 16, 25
end
[x,y]                # =&amp;gt; [0,0]: o bloco não altera essas variaveis.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Neste código, x é um parâmetro de bloco: ele recebe um valor quando o bloco é invocado com a produtividade. y é uma variável de
bloco-local. Ele não receber qualquer valor a partir de uma chamada `yield`, mas tem o valor nil até que o bloco de fato
atribui outro valor a ele. O ponto de declarar essas variáveis locais no ​​bloco é garantir que você não vai acidentalmente
sub-escrever o valor de alguma variável existente. Se você chamar Ruby 1.9 com o flag -w, ele irá avisá-lo se um bloco de
variável local de uma variável existente.

Os blocos podem ter mais do que um parâmetro e mais de uma variável local, é claro. Aqui é um bloco com dois parâmetros e
três variáveis ​​locais:

``` ruby Variavel Local
hash.each {|key,value; i,j,k| ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Passando argumentos para um bloco&lt;/h3&gt;

&lt;p&gt;Nós dissemos anteriormente que os parâmetros para um bloco são muito parecidos com os parâmetros de um método. Eles não são
rigorosamente iguais, no entanto. Os valores de argumento que seguem a palavra-chave &lt;code&gt;yield&lt;/code&gt; são designados para bloquear
parâmetros seguindo as regras que estão mais próximos as regras para a atribuição de variável do que as regras para a invocação
de método. Assim, quando um iterador executa &lt;code&gt;yield k,v&lt;/code&gt;, para invocar um bloco declarado com parâmetros &lt;code&gt;|key, value|&lt;/code&gt;, é
equivalente a esta instrução de atribuição:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição de parametros
key,value = k,v&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
O iterador `Hash.each_pair` produz um par `key/value` como este:

``` ruby Hash.each_pair
{:one=&amp;gt;1}.each_pair {|key,value| ... } # key=:one, value=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No Ruby 1.8, é ainda mais claro que a invocação do bloco usa atribuição de variável. Lembre-se que no Ruby 1.8, os parâmetros
são apenas locais para o bloco se não estiverem já em uso, como variáveis ​​locais do método que a contém. Se eles já são
variáveis locais, em seguida, eles são simplesmente atribuídos. Na verdade, Ruby 1.8 permite que qualquer tipo de variável seja
utilizada como um parâmetro de bloco, incluindo variáveis ​​globais e variáveis ​​de instância:&lt;/p&gt;

&lt;p&gt;```ruby Variaveis Locais e de Instância
{:one=&amp;gt;1}.each_pair {|$key, @value| &amp;hellip; } # Não funciona mais no Ruby 1.9&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Este iterator define a variável global `$key` para `:one` e define a variável de instância `@value` para `1`. Como já
mencionado, o Ruby 1.9 faz os parâmetros dos blocos locais para o bloco. Isto também significa que os parâmetros dos blocos não
podem mais ser variáveis ​​globais ou de instância.

Os iteradores `Hash.each` segue um pares de `key/value` como dois elementos de uma única matriz. É muito comum, no entanto,
para ver o código como esta:

```ruby Hash.each
hash.each {|k,v| ... }  # Chave e valor atribuído a params k e v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Isso também funciona por atribuição paralela. O valor cedido, um conjunto de dois elementos, é atribuído às variáveis ​​k e v:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
k, v = [value, key]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Pelas regras de atribuição paralela (ver &amp;lt;a href=&amp;quot;{{ root_url }}/blog/2012/06/11/atribuicao-paralela-number-ruby/&amp;quot;&amp;gt;Atribuição Paralela&amp;lt;/a&amp;gt;), uma única matriz da direita é expandida e seus elementos atribuídos às variáveis ​​múltiplas do lado esquerdo.

Bloco de invocação não funciona exatamente como atribuição paralela. Imagine um iterador que passa dois valores ao seu bloco.
Por as regras de atribuição paralela, podemos esperar para ser capaz de declarar um bloco com um único parâmetro e ter os dois
valores automaticamente preenchido em uma matriz para nós. Mas não é assim que funciona:

``` ruby Parametros
def two; yield 1,2; end # Um iterador que produz dois valores
two {|x| p x }          # Ruby 1.8: avisa e impressões [1,2],
two {|x| p x }     		# Ruby 1.9: imprime 1, nenhum aviso
two {|*x| p x }    		# versão Ou: impressões [1,2]; nenhum aviso
two {|x,| p x }    		# versão Ou: impressões 1; nenhum aviso
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No Ruby 1.8, vários argumentos são embalados em uma matriz, quando existe um parâmetro único no bloco, mas isso é obsoleto e
gera uma mensagem de aviso. No Ruby 1.9, o primeiro valor é atribuído ao parâmetro do bloco e o segundo valor é descartado. Se
queremos que vários valores podem a ser embalado em uma matriz e atribuído a um único parâmetro do bloco, nós devemos indicar
explicitamente que estamos prefixando o parâmetro com um &lt;code&gt;*&lt;/code&gt;, exatamente como faríamos em uma declaração de método. Observe
também que podemos descartar explicitamente o segundo valor ao declarar uma lista de parâmetros de bloco, que termina com uma
vírgula, como se dissesse:
    &amp;ldquo;Há um outro parâmetro, mas não é usado e eu não posso ser incomodado para escolher um nome para ele.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Embora invocação de bloco não se comporta como a atribuição paralela, neste caso, não se comportam como uma chamada de método,
também. Se declarar um método com um argumento e depois passar dois argumentos para ele, o Ruby não vai apenas imprimir um
aviso, vai também gerar um erro.&lt;/p&gt;

&lt;p&gt;A declaração do &lt;code&gt;yield&lt;/code&gt; permite que &lt;code&gt;hashes&lt;/code&gt; &amp;ldquo;nus&amp;rdquo; como o valor do último argumento, assim como invocações de métodos. Isto é,
se o último argumento para produzir é um literal de &lt;code&gt;hash&lt;/code&gt;, você pode omitir as chaves. Porque não é comum para iteradores para
produzir &lt;code&gt;hashes&lt;/code&gt;, temos que maquinar um exemplo para demonstrar isto:&lt;/p&gt;

&lt;p&gt;``` ruby Hashes sem chaves
def hashiter; yield :a=&amp;gt;1, :b=&amp;gt;2; end  # Nota final sem chaves
hashiter {|hash| puts hash[:a] }       # Imprime 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;h3&amp;gt;Bloquear Parâmetros no Ruby 1.9&amp;lt;/h3&amp;gt;

No Ruby 1.8, apenas o último parâmetro do bloco pode ter um prefixo `*`. Ruby 1.9 levanta essa restrição e permite qualquer
parâmetro do bloco, independentemente da sua posição na lista, para ter um prefixo `*`:

``` ruby Prefixo *
def five; yield 1,2,3,4,5; end     # Seguindo os 5 valores
five do |head, *body, tail|        # Valores extras entrar em matriz corpo
  print head, body, tail           # Mostra &amp;quot;1 [2,3,4] 5&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No Ruby 1.9 parâmetros do bloco podem ter valores padrões, apenas como parâmetros de método pode. Suponha, por exemplo, que
você deseja iterar os valores de um objeto, mas o que você não sabe se o obejeto é um &lt;code&gt;array&lt;/code&gt; ou um &lt;code&gt;hash&lt;/code&gt;. Você pode usar um
bloco como este:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Variavel com um valor pré determinado
o.each {|key=nil,value| puts value}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Se cada iterador produz um único valor, é atribuído ao segundo parâmetro do bloco. Se cada um produz um par de valores,
são atribuídos a ambos os parâmetros.&lt;/p&gt;

&lt;p&gt;No Ruby 1.9, o parâmetro do bloco final pode ser prefixado com e para indicar que vai receber qualquer bloco associado com a
invocação do bloco. Lembre, no entanto, que a invocação &lt;code&gt;yield&lt;/code&gt; pode não ter um bloco associado.&lt;/p&gt;

&lt;p&gt;Até o proximo assunto amigos.. :P&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>escrevendo iteradores personalizados number ruby 1 dot 9 2</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/08/05/escrevendo-iteradores-personalizados-number-ruby-1-dot-9-2/</link>
      <pubDate>Sun, 05 Aug 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/08/05/escrevendo-iteradores-personalizados-number-ruby-1-dot-9-2/</guid>
      <description>

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de `Escrevendo iteradores personalizados`... Estranho para alguns, mas, veremos que é simples!&lt;/p&gt;

&lt;h1&gt;Escrevendo iteradores personalizados&lt;/h1&gt;

&lt;p&gt;A definição de característica de um método &lt;code&gt;Iterator&lt;/code&gt;, é que ele invoca um bloco de código associado com a
invocação do método. Você faz isso com a declaração &lt;code&gt;yield&lt;/code&gt;. O método que se segue é um iterador trivial que apenas
invoca o seu bloco duas vezes:&lt;/p&gt;

&lt;p&gt;```ruby yield
def twice
  yield
  yield
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Para passar valores de argumento para o bloco, veja a declaração do `yield` com uma lista separada por vírgulas de
expressões. Tal como acontece com invocação de método, os valores dos argumentos podem, opcionalmente, ser colocada
com parênteses. O iterador simples a seguir mostra uma utilização do `yield`:

```ruby Method
# Este método espera um bloco. Gera n valores da forma
# M * i + c, para i de 0 .. n-1, e os yield deles, um de cada vez,
# Para o bloco associado.
def sequencia(n, m, c)
  i = 0
  while (i &amp;lt; n) # loop n vezes
    yield m * i + c # Invocar o bloco, e passar um valor a ela
    i += 1 # Incrementa i de cada vez
  end
end

# Aqui está uma invocação desse método, com um bloco.
# Ela imprime os valores 1, 6 e 11
sequencia(3, 5, 1) {| y | puts y}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Nomenclatura: rendimento e iteradores

Dependendo da sua experiência em programação, você pode encontrar os
termos &amp;quot;yield&amp;quot; e &amp;quot;iterator&amp;quot;. O método de sequencia mostrado anteriormente é
um bom exemplo claro de por que o &#39;yield&#39; tem o nome do que ele faz. Depois de calcular cada número
na sequencia, o método &#39;yield&#39; de controle (e produz o número calculado) para o bloco,
de modo que o bloco pode trabalhar com ele. Nem sempre é isso claro,
no entanto, em algum código que possa parecer como se fosse o bloco que é
produzindo um resultado de volta para o método que o invocou.

Um método como sequencia que espera um bloco e invoca-lo várias vezes é chamado de
&#39;iterador&#39;, porque parece e se comporta como um loop. Isso pode ser confuso se você está
acostumado a linguagens como Java em que iteradores são objetos. Em Java, o código que o cliente usa,
o iterador está no controle e &#39;puxa&#39; os valores do iterador quando ela precisa deles.
Em Ruby, o método iterator está no controle e &#39;empurra&#39; os valores para o bloco que quer.

Este problema de nomenclatura está relacionada com a distinção entre &#39;Iteradores interno&#39;
e &#39;iteradores externos&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aqui está outro exemplo de um &amp;lsquo;iterador&amp;rsquo; em Ruby; ele passa dois argumentos para o seu bloco. Vale notar
que a implementação deste iterador usa outro iterador internamente:&lt;/p&gt;

&lt;p&gt;```ruby  yield&lt;/p&gt;

&lt;h1 id=&#34;gera-n-pontos-uniformemente-espaçados-em-torno-da-circunferência-de-um&#34;&gt;Gera n pontos uniformemente espaçados em torno da circunferência de um&lt;/h1&gt;

&lt;h1 id=&#34;círculo-de-raio-r-centrado-em-0-0-rendimento-da-coordenadas-x-e-y&#34;&gt;Círculo de raio r centrado em (0,0). Rendimento da coordenadas X e Y&lt;/h1&gt;

&lt;h1 id=&#34;de-cada-ponto-ao-bloco-associado&#34;&gt;De cada ponto ao bloco associado.&lt;/h1&gt;

&lt;p&gt;def circle(r,n)
  n.times do |i|    #  Observe que este método é implementado com um bloco
    angle = Math::PI * 2 * i / n
    yield r*Math.cos(angle), r*Math.sin(angle)
  end
end&lt;/p&gt;

&lt;h1 id=&#34;esta-invocação-das-impressões-iterador&#34;&gt;Esta invocação das impressões iterador:&lt;/h1&gt;

&lt;h1 id=&#34;1-00-0-00-0-00-1-00-1-00-0-00-0-00-1-00&#34;&gt;(1,00, 0,00) (0,00, 1,00) (-1,00, 0,00) (-0,00, -1,00)&lt;/h1&gt;

&lt;p&gt;circle(1,4) {|x,y| printf &amp;ldquo;(%.2f, %.2f)&amp;rdquo;, x, y }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Usando a palavra-chave `yield` realmente é muito parecido com invocação de um método.
Parênteses nos argumentos são opcionais. Você pode usar `*` para expandir uma matriz de argumentos
individuais. `yield` ainda permite que você passe um hash literal sem as chaves ao seu redor. Ao contrário
de uma invocação de método, no entanto, uma expressão `yield` pode não ser seguido por um bloco.
Você não pode passar um bloco a um bloco.

Se um método é invocado sem um bloco, é um erro para o método `yield`, porque não há nada para `yield`. Às vezes
você querer escrever um método que produz a um bloco se for fornecido, mas tem alguma ação padrão (outro de lançar
um erro), se invocado com nenhum bloco. Para fazer isso, use `block_given?` para determinar se há um bloco
associado com a chamada. `block_given?`, e seu sinônimo `iterator?`, são métodos do Kernel, então eles agem como
funções mundiais. Aqui está um exemplo:

```ruby block_biven?
# Retorna um array com n elementos da forma m * i + c
# Se um bloco é dado, igualmente produzir cada elemento para o bloco
def sequence(n, m, c)
  i, s = 0, []                  # Inicializa variáveis
  while(i &amp;lt; n)                  # Loop n vezes
    y = m*i + c                 # calcula o valor
    yield y if block_given?
    s &amp;lt;&amp;lt; y                      # armazena o valor
    i += 1
  end
  s             # Retorna o array de valores
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É isso aí!&lt;/p&gt;

&lt;p&gt;Até o proximo!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>objetos enumeraveis number ruby 1 dot 9 2</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/07/25/objetos-enumeraveis-number-ruby-1-dot-9-2/</link>
      <pubDate>Wed, 25 Jul 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/07/25/objetos-enumeraveis-number-ruby-1-dot-9-2/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de `Objetos Enumeráveis`... Estranho para alguns, mas, veremos que é simples!&lt;/p&gt;

&lt;h1&gt;Objetos Enumeráveis&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Range&lt;/code&gt;, &lt;code&gt;Hash&lt;/code&gt;, e um número de outras classes definem um iterador &lt;code&gt;each&lt;/code&gt; que passa cada elemento da
coleção para o bloco associado. Este é talvez o mais comumente usado iterador em Ruby, o loop só funciona para
iterar sobre objetos que têm o método &lt;code&gt;each&lt;/code&gt;. Exemplos de iteradores &lt;code&gt;each&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;```ruby Metodo each
[1,2,3].each {|x| print x }   # =&amp;gt; prints &amp;ldquo;123&amp;rdquo;
(1..3).each  {|x| print x }   # =&amp;gt; prints &amp;ldquo;123&amp;rdquo; Same as 1.upto(3)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
O iterador `each` não é só para as classes tradicionais &amp;quot;de estrutura de dados&amp;quot;. Classes `IO` Ruby definem um
iterador `each` que cada linha de texto lido do objeto produz `Input/Output`. Assim, você pode processar as linhas
de um arquivo em Ruby com um código como esse:

```ruby Metodo each para File
File.open(filename) do |f|       # Abrir arquivo nomeado, passando f como parametro
  f.each {|line| print line }    # Imprimir f em cada linha
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A maioria das classes que definem um método &lt;code&gt;each&lt;/code&gt; também incluem o módulo &lt;code&gt;Enumerable&lt;/code&gt;, que define um número de
iteradores mais especializados que são implementados em cima do método &lt;code&gt;each&lt;/code&gt;. Um iterador é útil tal &lt;code&gt;each_with_index&lt;/code&gt;, o que nos permite adicionar a linha de numeração para o exemplo anterior:&lt;/p&gt;

&lt;p&gt;``` ruby Metodo each com Index
File.open(filename) do |f|
  f.each_with_index do |line,number|
    print &amp;ldquo;#{number}: #{line}&amp;rdquo;
  end
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Alguns dos iteradores mais comumentes utilizados são os métodos `Enumerable`, `collect`, `select`, `reject`, e
`inject`. O método `collect` (também conhecido como `map`) executa o seu bloco associado para cada elemento do objeto
enumerável, e coleta os valores de retorno dos blocos em um `array`:

```ruby Metodo Collect
quadrados = [1,2,3].collect {|x| x*x}   # =&amp;gt; [1,4,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O método &lt;code&gt;select&lt;/code&gt; invoca o bloco associado para cada elemento no objeto enumerável, e retorna uma matriz de
elementos para a qual o bloco retorna um outro valor &lt;code&gt;false&lt;/code&gt; ou &lt;code&gt;nil&lt;/code&gt;. Por exemplo:&lt;/p&gt;

&lt;p&gt;```ruby Metodo Select
nivela = (1..10).select{|x| x%2 == 0} # =&amp;gt; [2,4,6,8,10]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
O método `reject` é simplesmente o oposto de `select`, ele retorna uma matriz de elementos para a qual o bloco
retorna `nil` ou `false`. Por exemplo:

```ruby Metodo reject
odds = (1..10).reject{|x| x%2 == 0} # =&amp;gt; [1,3,5,7,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O método &lt;code&gt;inject&lt;/code&gt; é um pouco mais complicado do que os outros. Ele invoca o bloco associado com dois argumentos.
O primeiro argumento é um valor acumulado de algum tipo das iterações anteriores. O segundo argumento é o próximo
o objeto enumerável. O valor de retorno do bloco é o primeiro argumento bloqueado para a próxima iteração, ou torna-
se o valor de retorno do iterador após a última iteração. O valor inicial da variável acumula ou é o argumento de
&lt;code&gt;inject&lt;/code&gt;, se houver um, ou o primeiro elemento do objeto enumerável. (Neste caso, o bloco é invocado. Apenas uma vez durante os primeiros dois elementos). Exemplos para &lt;code&gt;injects&lt;/code&gt; mais claros:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Metodo Inject
data = [2, 5, 3, 4]
sum = data.inject{|sum, x| sum + x }      # =&amp;gt; 14    (2+5+3+4)
floatprod = data.inject(1.0){|p,x| p*x }  # =&amp;gt; 120.0 (1.0*2*5*3*4)
max = data.inject{|m,x| m&amp;gt;x ? m : x }     # =&amp;gt; 5     (elemento maior)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Veja &lt;a href=&#34;http://ruby-doc.org/core-1.9.2/Enumerable.html&#34;&gt;Objetos Enumeráveis&lt;/a&gt; ​​para obter mais detalhes sobre o &lt;code&gt;Módulo Enumerable&lt;/code&gt; e a seus iteradores.&lt;/p&gt;

&lt;p&gt;Até a proxima amigos&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iteradores numericos</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/07/14/iteradores-numericos/</link>
      <pubDate>Sat, 14 Jul 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/07/14/iteradores-numericos/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de `Iteradores Numéricos`... Estranho para alguns, mas, veremos que é simples!&lt;/p&gt;

&lt;h1&gt;Iteradores Numéricos&lt;/h1&gt;

&lt;p&gt;O núcleo do &lt;code&gt;Ruby API&lt;/code&gt; fornece um número de iteradores padrão. Os métodos de loops do Kernel se comporta como um
loop infinito, executando seu bloco associado repetidamente até que o bloco executa um &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, ou outra
declaração que sai do laço.&lt;/p&gt;

&lt;p&gt;A classe &lt;code&gt;Integer&lt;/code&gt; define três iteradores usados. O método &lt;code&gt;upto&lt;/code&gt; chama seu bloco associado uma vez para cada número
inteiro entre o número inteiro no qual ele é invocado e o número inteiro que é passado como um argumento.
Por exemplo:&lt;/p&gt;

&lt;p&gt;``` ruby upto
4.upto(6){|x| print x} # =&amp;gt; prints &amp;ldquo;456&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Como você pode ver, `upto` intera cada número inteiro para o bloco associado, e inclui tanto o ponto de partida e o
ponto final na iteração. Em geral, `n.upto(m)` é executado o bloco `m-n +1` vezes.

O método `downto` é como `upto` mas itera a partir de um maior número para um número menor.

Quando o método `Integer.times` é chamado no `n` inteiro, invoque o seu bloco de `n vezes`, passando os valores de
`0 a n-1` em iterações sucessivas. Por exemplo:

``` ruby times
3.times {|x| print x }    # =&amp;gt; prints &amp;quot;012&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Em geral, é &lt;code&gt;n.times&lt;/code&gt; equivalente a &lt;code&gt;0.upto(n-1)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se você quer fazer uma iteração numérica usando um ponto flutuante de números, você pode usar o método &lt;code&gt;step&lt;/code&gt; mais
complexo definido pela classe numérica. O iterador a seguir, por exemplo, começa a 0 e itera em passos de 0.1 até
atingir &lt;code&gt;Math::PI&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby metodo step
0.step(Math::PI, 0.1){|x| puts Math.sin(x)}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Até a proxima!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>unless number ruby 1 dot 9</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/07/05/unless-number-ruby-1-dot-9/</link>
      <pubDate>Thu, 05 Jul 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/07/05/unless-number-ruby-1-dot-9/</guid>
      <description>

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de `unless`... Estranho para alguns, mas, veremos que é simples!&lt;/p&gt;

&lt;h1&gt;Unless&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;unless&lt;/code&gt;, como uma declaração ou um modificador, é o oposto do &lt;code&gt;case&lt;/code&gt;: ele executa o código apenas se uma expressão
associada é avaliada como &lt;code&gt;false&lt;/code&gt; ou &lt;code&gt;nil&lt;/code&gt;. Sua sintaxe é como &lt;code&gt;if&lt;/code&gt;, exceto que as cláusulas &lt;code&gt;elsif&lt;/code&gt;, que não são
permitidas:&lt;/p&gt;

&lt;p&gt;``` ruby Declaração unless&lt;/p&gt;

&lt;h1 id=&#34;uma-maneira-declaração-unless&#34;&gt;Uma maneira, declaração unless&lt;/h1&gt;

&lt;p&gt;unless condition
  code
end&lt;/p&gt;

&lt;h1 id=&#34;duas-vias-da-declaração-unless&#34;&gt;Duas vias da declaração unless&lt;/h1&gt;

&lt;p&gt;unless condition
  code
else
  code
end&lt;/p&gt;

&lt;h1 id=&#34;modificador-unless&#34;&gt;modificador unless&lt;/h1&gt;

&lt;p&gt;code unless condition&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
A declaração `unless`, como a declaração `if`, exige que a condição e o código são separados por uma mudança de linha,
uma vírgula, ou a palavra-chave `then`. Também como `if`, as declarações `unless` são expressões e retornam o valor do
código que são executados, ou `nil` se executar nada:

``` ruby Declaração unless
# Chama o método to_s sobre o objeto, a menos que o objeto &#39;o&#39; for nulo
s = unless o.nil?                        # Nova linha de separação
  o.to_s
end

s = unless o.nil? then o.to_s end        # separador então
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para uma única linha condicionais como esta, a forma do modificador &lt;code&gt;unless&lt;/code&gt; é geralmente mais clara:&lt;/p&gt;

&lt;p&gt;``` ruby Unless
s = o.to_s unless o.nil?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Ruby não tem nenhum equivalente da cláusula `elsif` para a condicional `unless`. Você ainda pode escrever um multiway da instrução `unless`, no entanto, se você está disposto a ser um pouco mais detalhado:

``` ruby unless
unless x == 0
  puts &amp;quot;x is not 0&amp;quot;
else
  unless y == 0
    puts &amp;quot;y is not 0&amp;quot;
  else
    unless z == 0
      puts &amp;quot;z is not 0&amp;quot;
    else
      puts &amp;quot;all are 0&amp;quot;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É isso ai amigos!&lt;/p&gt;

&lt;p&gt;Para todos aqueles que não sabiam ao certo o que seria o &lt;code&gt;unless&lt;/code&gt;, e que tipo de monstro é isso..&lt;/p&gt;

&lt;p&gt;Esta ai..&lt;/p&gt;

&lt;p&gt;Até a proxima!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>demonstracoes e estruturas de controle</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/18/demonstracoes-e-estruturas-de-controle/</link>
      <pubDate>Mon, 18 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/18/demonstracoes-e-estruturas-de-controle/</guid>
      <description>

&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Demonstrações e estruturas de controle&lt;/p&gt;

&lt;h1&gt;Demonstrações e estruturas de controle&lt;/h1&gt;

&lt;p&gt;Considere o programa Ruby seguinte. Acrescenta dois números passados ​​para na linha de comando e imprime a soma:&lt;/p&gt;

&lt;p&gt;``` ruby Programa Simples
x = ARGV[0].to_f # Converter primeiro argumento para um número
y = ARGV[1].to_f # Converter segundo argumento para um número
soma = x + y # Adicione os argumentos
puts soma # Imprimir a soma&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Este é um programa simples que consiste essencialmente em invocar variável de atribuição e método. O que o torna
particularmente simples é sua execução puramente seqüencial. As quatro linhas de código são executadas uma após a outra
sem ramificação ou repetição. É um programa raro que pode ser tão simples.


&amp;lt;h3&amp;gt;Condicionais&amp;lt;/h3&amp;gt;

A estrutura de controle mais comum, em qualquer linguagem de programação, é a condicional. Esta é uma forma de dizer ao
computador para condicionalmente executar alguns códigos: para executar ele, só se alguma condição for satisfeita.
A condição é uma expressão, se for avaliada como qualquer valor diferente de falso ou nulo, então a condição é satisfeita.

Ruby tem um vocabulário rico para expressar condicionais. Algumas sintaxes são descritas abaixo. Ao escrever código Ruby,
você pode escolher o que parece mais elegante para a tarefa.


&amp;lt;h5&amp;gt;if&amp;lt;/h5&amp;gt;

Ele é a mais simples das condicionais. Em sua forma mais simples, parece que isso:

``` ruby Condicional IF
if expression
  code
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código entre &lt;code&gt;if&lt;/code&gt; e &lt;code&gt;end&lt;/code&gt;é executado se (e somente se) o &lt;code&gt;expression&lt;/code&gt; é avaliada como algo diferente que &lt;code&gt;falso&lt;/code&gt; ou
&lt;code&gt;nulo&lt;/code&gt;. O código deve ser separado a partir da expressão com uma nova linha ou ponto e vírgula ou a palavra-chave, em
seguida. Aqui estão duas maneiras de escrever a mesma condicional &lt;code&gt;if&lt;/code&gt; de forma simples:&lt;/p&gt;

&lt;p&gt;```ruby Condicional IF&lt;/p&gt;

&lt;h1 id=&#34;se-x-é-menor-que-10-incrementá-lo&#34;&gt;Se x é menor que 10, incrementá-lo&lt;/h1&gt;

&lt;p&gt;if x &amp;lt; 10 # nova linha de separação
  x + = 1
end
if x &amp;lt; 10 then x += 1 end # the separato&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Você também pode usar `then` como o símbolo de separação, e segui-lo com uma nova linha. Isso torna o seu código robusto.

``` ruby Condicional IF
if x &amp;lt; 10 then
  x + = 1
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os programadores que estão acostumados a C, ou linguagens cuja sintaxe é derivada de C, deve observar duas coisas
importantes sobre if no Ruby:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Parênteses não é necessário (e normalmente não utilizado) em torno da expressão condicional. O ponto e vírgula, quebra
de linha, ou então palavra-chave serve para delimitar a expressão.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A palavra-chave &lt;code&gt;end&lt;/code&gt; é exigida, mesmo quando o código a ser executado condicionalmente consiste de uma única instrução.
A forma modificador do &lt;code&gt;if&lt;/code&gt;, descrito abaixo, fornece uma maneira para gravar condicionais simples sem a palavra-chave &lt;code&gt;end&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;else&lt;/h5&gt;

&lt;p&gt;Uma declaração &lt;code&gt;if&lt;/code&gt; pode incluir uma cláusula &lt;code&gt;else&lt;/code&gt; para especificar o código para ser executado se a condição não é
&lt;code&gt;true&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` ruby Condicional else
if expression
  code
else
  code
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
O código entre `if` e `else` é executado se `expression` é avaliada como qualquer outra coisa que `false` ou `nil`. Caso
contrário (se expression é `false` ou `nil`), o código entre o `else` e o `end` é executado. Como na forma simples
de `if`, na expressão deve ser separado do código que o segue por uma nova linha, um ponto e vírgula, ou a palavra-chave `then`. As palavras-chave `else` e `end`, totalmente delimitam o segundo pedaço de código, e sem novas linhas ou
delimitadores adicionais são exigido.

Aqui é um exemplo de um condicional que inclui uma cláusula `else`:

``` ruby Condicional if - else
if dados # Se o array existe
  dados &amp;lt;&amp;lt; x # em seguida, acrescentar um valor a ela.
else # Caso contrário ...
  data = [x] # criar uma nova matriz que contém o valor.
end # Este é o fim do condicional
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;elsif&lt;/h5&gt;

&lt;p&gt;Se você quiser testar mais de uma condição dentro de uma condicional, você pode adicionar um ou mais cláusulas &lt;code&gt;elsif&lt;/code&gt;
entre um &lt;code&gt;if&lt;/code&gt; e um &lt;code&gt;else&lt;/code&gt;. &lt;code&gt;elsif&lt;/code&gt; é uma forma abreviada de &lt;code&gt;else if&lt;/code&gt;. Note que há apenas um &lt;code&gt;else&lt;/code&gt; em &lt;code&gt;elsif&lt;/code&gt;. A condicional &lt;code&gt;elsif&lt;/code&gt; usando parecido com este:&lt;/p&gt;

&lt;p&gt;```ruby Expressão elsif
if expression1
  code1
elsif expression2
  code2
      .
      .
      .
elsif expressionN
  codeN
else
  code
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Se `expression1` for avaliado não sendo `false` ou `nil`, então `code1` é executado. Caso contrário, `expression2` é
avaliada. Se for outra coisa senão `false` ou `nil`, então code2 é executado. Este processo continua até que uma expressão
é avaliada como algo diferente de `false` ou `nil`, ou até que todas as cláusulas `elsif` foram testadas. Se a expressão
associada com a última cláusula `elsif` for `false` ou `nil`, e da cláusula `elsif` é seguido por uma cláusula `else`, em
seguida, o código entre `else` e no `end` é executado. Se nenhuma cláusula mais está presente, em seguida, nenhum código é
executado.

`elsif` é como se: a expressão deve ser separada do código por uma nova linha, uma vírgula ou uma palavra-chave, em seguida
. Aqui é um exemplo de uma multi condicional usando `elsif`:

```ruby Condicional elsif
if x == 1
  name = &amp;quot;um&amp;quot;
elsif x == 2
  name = &amp;quot;dois&amp;quot;
elsif x == 3 then name = &amp;quot;três&amp;quot;
elsif x == 4; name = &amp;quot;quatro&amp;quot;
else
  name = &amp;quot;muitos&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Valor de retorno&lt;/h5&gt;

&lt;p&gt;Na maioria das linguagens, a condicional &lt;code&gt;if&lt;/code&gt; é uma afirmação. Em Ruby, no entanto, tudo é uma expressão, mesmo as
estruturas de controle que são comumente chamadas de declarações. O valor &lt;code&gt;return&lt;/code&gt; de uma &amp;ldquo;declaração&amp;rdquo; &lt;code&gt;if&lt;/code&gt;, é o valor da
última expressão no código que foi executado, ou &lt;code&gt;nil&lt;/code&gt; se nenhum bloco de código foi executado.&lt;/p&gt;

&lt;p&gt;O fato de que, as declarações &lt;code&gt;if&lt;/code&gt; devolvem um valor significa que, por exemplo, a muilti condicional mostrado
anteriormente pode ser elegantemente reescrito como este abaixo:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Valor de Retorno
name = if x == 1 then &amp;quot;um&amp;quot;
       elsif x == 2 then &amp;quot;dois&amp;quot;
       elsif x == 3 then &amp;quot;três&amp;quot;
       elsif x == 4 then &amp;quot;quatro&amp;quot;
       else &amp;quot;muitos&amp;quot;
       end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;É isso aí amigos..&lt;/p&gt;

&lt;p&gt;Bons estudos e até a proxima! :D&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>atribuicao paralela number ruby</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/11/atribuicao-paralela-number-ruby/</link>
      <pubDate>Mon, 11 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/11/atribuicao-paralela-number-ruby/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Atribuições Paralelas&lt;/p&gt;

&lt;h1&gt;Atribuições Paralelas&lt;/h1&gt;

&lt;p&gt;Atribuição paralela é qualquer atribuição de expressão que tem mais do que um &lt;code&gt;lvalue&lt;/code&gt;, mais do que um &lt;code&gt;rvalue&lt;/code&gt;, ou ambos. Múltiplos &lt;code&gt;lvalues&lt;/code&gt; e ​​múltiplos &lt;code&gt;rvalues&lt;/code&gt; são separados uns dos outros com uma vírgula. &lt;code&gt;lvalues&lt;/code&gt; e &lt;code&gt;rvalues&lt;/code&gt; ​​pode ser prefixado com &lt;code&gt;*&lt;/code&gt;, que às vezes é chamado de operador &lt;code&gt;splat&lt;/code&gt;, embora não seja um verdadeiro operador. O significado de &lt;code&gt;*&lt;/code&gt; é explicado mais adiante neste post.&lt;/p&gt;

&lt;p&gt;Expressões de atribuição mais paralelas são simples, e é óbvio que eles significam. Existem alguns casos complicados, no entanto, e os subtitulos seguintes explicam todas as possibilidades.&lt;/p&gt;

&lt;h5&gt;Mesmo número de lvalues ​​e rvalues&lt;/h5&gt;

&lt;p&gt;Atribuição paralela é a sua forma mais simples quando não são os mesmos número de &lt;code&gt;lvalues&lt;/code&gt; ​​e &lt;code&gt;rvalues&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição de Mesmo número
x, y, z = 1, 2, 3 # x = 1; y = 2; z = 3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Neste caso, o primeiro `rvalue` é atribuído ao primeiro `lvalue`; o segundo `rvalue` é atribuído ao segundo `lvalue`, e assim por diante.

Estas atribuições são efetivamente executadas em paralelo, não seqüencialmente. Por exemplo, as seguintes duas linhas não são as mesmas:

``` ruby Atribuição
x, y = y, x # Paralela: trocar o valor de duas variáveis
x = y; y = x # seqüencial: ambas as variáveis ​​têm o mesmo valor
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Um lvalue, ​​múltiplos rvalues&lt;/h5&gt;

&lt;p&gt;Quando há um único &lt;code&gt;lvalue&lt;/code&gt; e mais do que um &lt;code&gt;rvalue&lt;/code&gt;, Ruby cria um &lt;code&gt;array&lt;/code&gt; para armazenar os &lt;code&gt;rvalues&lt;/code&gt; ​​e atribui esse &lt;code&gt;array&lt;/code&gt; para o &lt;code&gt;lvalue&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` ruby Um lvalue e Múltiplos rvalues
x = 1, 2, 3 # x = [1,2,3]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Você pode colocar um `*` antes do lvalue sem alterar o significado ou o valor de retorno desta atribuição.

Se você quiser impedir que os ​múltiplos `rvalues` de serem combinados em um único `array`, siga o `lvalue` com uma vírgula. Mesmo sem um lvalue depois da vírgula, isto torna que o Ruby se comporte como se há ​​múltiplos lvalues:

``` ruby Atribuições
x, = 1, 2, 3 # x = 1; outros valores são descartados
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;M​últiplos lvalues, array único de rvalue&lt;/h5&gt;

&lt;p&gt;Quando existem múltiplos &lt;code&gt;lvalues​&lt;/code&gt; e apenas um único &lt;code&gt;rvalue&lt;/code&gt;, Ruby tenta expandir o rvalue em uma &lt;code&gt;lista&lt;/code&gt; de valores a atribuir. Se o &lt;code&gt;rvalue&lt;/code&gt; é um &lt;code&gt;array&lt;/code&gt;, Ruby expande o &lt;code&gt;array&lt;/code&gt; para que cada elemento torna-se seu próprio &lt;code&gt;rvalue&lt;/code&gt;. Se o &lt;code&gt;rvalue&lt;/code&gt; não é um &lt;code&gt;array&lt;/code&gt;, mas implementa um método &lt;code&gt;to_ary&lt;/code&gt;, Ruby invoca esse método e, em seguida, se expande o &lt;code&gt;array&lt;/code&gt; no retorno:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
x, y, z = [1, 2, 3] # mesmo que x, y, z = 1,2,3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
A atribuição paralela foi transformado de modo que há ​​múltiplos `lvalues` e zero (se expandida o `array` estando `empty`) ou mais `rvalues`. Se o número de `lvalues` ​​e `rvalues` ​​são os mesmos, então a atribuição ocorre conforme descrito anteriormente, Mesmo número de lvalues ​​e rvalues`. Se os números são diferentes, então a atribuição ocorre como descrito a seguir em `Diferentes números de lvalues ​​e rvalues`.

Podemos usar o truque de fuga por vírgula descrito acima para transformar uma sessão ordinária não paralela em uma atribuição que automaticamente descompacta um `array` à direita:

``` ruby Atribuição
x = [1,2] # x torna-se [1,2]: isso não é atribuição paralela
x, = [1,2] # x torna-se 1: da vírgula torna paralelo
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Diferentes números de lvalues ​​e rvalues&lt;/h5&gt;

&lt;p&gt;Se houver &lt;code&gt;lvalues&lt;/code&gt; mais do que ​​&lt;code&gt;rvalues&lt;/code&gt;, e nenhum operador &lt;code&gt;splat&lt;/code&gt; é envolvido, em seguida, o primeiro &lt;code&gt;rvalue&lt;/code&gt; é atribuído ao primeiro &lt;code&gt;lvalue&lt;/code&gt;, o segundo &lt;code&gt;rvalue&lt;/code&gt; é atribuído ao segundo &lt;code&gt;lvalue&lt;/code&gt;, e assim por diante, até todos os &lt;code&gt;rvalues&lt;/code&gt; ​​forem atribuídos. Em seguida, cada um dos restantes &lt;code&gt;lvalues&lt;/code&gt; ​​é atribuído nil, substituindo qualquer valor existente para que &lt;code&gt;lvalue&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
x, y, z = 1, 2 # x = 1; y = 2; z = nil&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Se houver `rvalues` mais do que ​`​lvalues`, e nenhum operador `splat` é envolvido, em seguida, os `rvalues` ​são atribuídos em ordem a cada um dos `lvalues`, e os restantes `rvalues` são descartados :

```ruby Atribuição
x, y = 1, 2, 3 # x = 1; y = 2, 3 não é atribuído
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;O operador splat&lt;/h5&gt;

&lt;p&gt;Quando um &lt;code&gt;rvalue&lt;/code&gt; é precedido por um asterisco(&lt;code&gt;*&lt;/code&gt;), isso significa que o referido valor é um &lt;code&gt;array&lt;/code&gt; e que seus elementos devem ser cada um &lt;code&gt;rvalues&lt;/code&gt;. Os elementos do &lt;code&gt;array&lt;/code&gt; substituem o &lt;code&gt;array&lt;/code&gt; na lista original do &lt;code&gt;rvalue&lt;/code&gt;, e a atribuição procede como descrito abaixo:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
x, y, z = 1, * [2,3] # mesmo que x, y, z = 1,2,3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
No Ruby 1.8, um splat só pode aparecer antes do último `rvalue` em uma atribuição. No Ruby 1.9, a lista de `rvalues` ​​em uma atribuição paralela pode ter qualquer número de `splats`, e eles podem aparecer em qualquer posição na lista. Não é legal, porém, em qualquer versão da linguagem, para tentar um &amp;quot;splat double&amp;quot; em uma lista aninhada:

```ruby Erro de Atribuição
x,y = **[[1,2]]   # SyntaxError!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os &lt;code&gt;rvalues&lt;/code&gt; com i​ntervalo de &lt;code&gt;arrays&lt;/code&gt; e de &lt;code&gt;hash&lt;/code&gt; pode ser &lt;code&gt;splatted&lt;/code&gt;. Em geral, qualquer &lt;code&gt;rvalue&lt;/code&gt; que define um método &lt;code&gt;to_a&lt;/code&gt; pode ser prefixado com um &lt;code&gt;splat&lt;/code&gt;. Qualquer objeto &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Enumerable.html&#34;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt;, incluindo enumeradores pode ser &lt;code&gt;splatted&lt;/code&gt;, por exemplo. Quando um &lt;code&gt;splat&lt;/code&gt; é aplicado a um objecto que não define um método &lt;code&gt;to_a&lt;/code&gt;, nenhuma expansão é realizada e o &lt;code&gt;splat&lt;/code&gt; avaliado como o próprio objeto.&lt;/p&gt;

&lt;p&gt;Quando um &lt;code&gt;lvalue&lt;/code&gt; é precedido por um asterisco(&lt;code&gt;*&lt;/code&gt;), isso significa que todos ​​os adicionais &lt;code&gt;rvalues&lt;/code&gt; devem ser colocados em um &lt;code&gt;array&lt;/code&gt; e atribuído ao &lt;code&gt;lvalue&lt;/code&gt;. O valor atribuído a esse &lt;code&gt;lvalue&lt;/code&gt; é sempre um &lt;code&gt;array&lt;/code&gt;, e ele pode ter zero, um ou mais elementos:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
x,*y = 1, 2, 3  # x=1; y=[2,3]
x,*y = 1, 2     # x=1; y=[2]
x,*y = 1        # x=1; y=[]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
No Ruby 1.8, um `splat` só pode preceder o `lvalue` passado na lista. No Ruby 1.9, do lado esquerdo de uma atribuição paralela pode incluem um operador `splat`, mas pode aparecer em qualquer posição na lista:

``` ruby Atribuição
# Ruby 1.9 somente
*x,y = 1, 2, 3  # x=[1,2]; y=3
*x,y = 1, 2     # x=[1]; y=2
*x,y = 1        # x=[]; y=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note-se que &lt;code&gt;splats&lt;/code&gt; pode aparecer em ambos os lados de uma expressão paralela de atribuição:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
x, y, *z = 1, *[2,3,4]  # x=1; y=2; z=[3,4].&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Finalmente, lembre-se que anteriormente descrevemos dois casos simples de atribuição paralela em que há um `lvalue` único ou uma única `rvalue`. Note-se que ambos os casos se comportam como se existe um `splat` antes da única `lvalue` ou `rvalue`. Explicitamente, incluindo um `splat` em nestes casos não tem qualquer efeito adicional.


&amp;lt;h5&amp;gt;Parênteses na atribuição paralelo&amp;lt;/h5&amp;gt;

Uma das características menos compreendidas da atribuição paralela é que o lado esquerdo pode usar parênteses para &amp;quot;sub atrobuição&amp;quot;. Se um grupo de dois ou mais `lvalues` ​​é colocado entre parênteses, então é inicialmente tratada como um `lvalue` único. Uma vez que o `rvalue` correspondente foi determinado, as regras de atribuição paralela são aplicadas recursivamente, o `rvalue` que é atribuído ao grupo de `lvalues` ​​que foi em parênteses. Considere o seguinte exercício:

```ruby Atribuição
x, (y, z) = a, b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este é efetivamente executam dois trabalhos ao mesmo tempo:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
x = a
y,z = b&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Mas note que a segunda tarefa é em si uma atribuição paralela. Como usamos parênteses no lado esquerdo, uma atribuição paralela recursiva é executada. Em ordem para que ele funcione, b deve ser um objeto `splattable` como um `array` ou `enumerador`.

Aqui estão alguns exemplos concretos que devem tornar isso mais claro. Note que os parênteses no ato da esquerda a &amp;quot;desembrulhar&amp;quot; um nível de `array` alinhado à direita:

```ruby Atribuição
x,y,z = 1,[2,3]             # Sem parenteses: x=1;y=[2,3];z=nil
x,(y,z) = 1,[2,3]           # Parenteses: x=1;y=2;z=3

a,b,c,d = [1,[2,[3,4]]]     # Sem parenteses: a=1;b=[2,[3,4]];c=d=nil
a,(b,(c,d)) = [1,[2,[3,4]]] # Parenteses: a=1;b=2;c=3;d=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É isso aí amigos..&lt;/p&gt;

&lt;p&gt;Bons estudos e até a proxima! :D&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>atribuicoes</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/03/atribuicoes/</link>
      <pubDate>Sun, 03 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/03/atribuicoes/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Atribuições&lt;/p&gt;

&lt;h1&gt;Atribuições&lt;/h1&gt;

&lt;p&gt;Uma expressão de atribuição especifica um ou mais valores para um ou mais valores. lvalue é o termo para algo que pode aparecer no lado
esquerdo de uma atribuição do operador. Os valores no lado direito de um operador de atribuição são algumas vezes chamado de rvalues ​​por
contraste. Variáveis, constantes, atributos e elementos do Array são lvalues ​​em Ruby. As regras para o significado de expressões de
atribuição são um pouco diferente para diferentes tipos de lvalues, e cada tipo é descrito em detalhe neste post.&lt;/p&gt;

&lt;p&gt;Existem três diferentes formas de expressões de atribuição em Ruby. Atribuição simples envolve um lvalue do operador &lt;code&gt;=&lt;/code&gt;, e um rvalue.
Para exemplo:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
x = 1 # Define o lvalue x para o valor 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Atribuição abreviada é uma expressão abreviada que atualiza o valor de uma variável através da aplicação de alguma outro operador (tais
como a adição) ao valor atual da variável. Atribuição abreviada utiliza a atribuição de operadores como &amp;lt;code&amp;gt;+=&amp;lt;/code&amp;gt; e &amp;lt;code&amp;gt;*=&amp;lt;/code&amp;gt; que combinam operadores binários com uma sinal de igual:

``` ruby Atribuição
x += 1 # Define o lvalue x para o valor de x + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por fim, a atribuição paralela é qualquer expressão de atribuição que tem mais do que um lvalue ou mais do que um rvalue. Aqui é um simples exemplo:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
x, y, z = 1,2,3 # Definir x a 1, y a 2 e z a 3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Atribuição paralela é mais complicado quando o número de lvalues não é o mesmo que o número de rvalues ​​ou quando existe um `array` sobre à direita.

O valor de uma expressão de atribuição é o valor (ou um `array` dos valores) atribuído. Além disso, o operador de atribuição
é &amp;quot;Associativo à direita&amp;quot;, se aparecer várias atribuições em uma única expressão, eles são avaliados da direita para a esquerda.
Isto significa que a atribuição pode ser acorrentado para atribuir o mesmo valor para as múltiplas variáveis:

```ruby Atribuição
x = y = 0 # X e Y recebem 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note-se que este não é um caso de atribuição paralela é duas atribuições simples, acorrentados juntos: Y é atribuído o valor 0, e então x é atribuído o valor da primeira tarefa (também 0).&lt;/p&gt;

&lt;h5&gt;Atribuindo a Variáveis&lt;/h5&gt;

&lt;p&gt;Quando nós pensamos em atribuição, geralmente pensamos em variáveis ​​e, na verdade, estes são os mais comuns em expressões de atribuição de lvalues. Lembre-se que Ruby tem quatro tipos de variáveis: variáveis ​​locais, variáveis ​​globais, variáveis ​​de instância e variáveis ​​de classe. Estes são distintas um do outro, pelo primeiro carácter no nome da variável. Atribuição funciona da mesma forma para todos os quatro tipos de variáveis, de modo que não é necessário fazer a distinção entre os tipos de variáveis ​​aqui.&lt;/p&gt;

&lt;p&gt;Tenha em mente que as variáveis ​​de instância de objetos do Ruby são nunca nomes visíveis fora do objeto, e variável nunca é qualificado com um nome de objeto. Considere esta atribuição:&lt;/p&gt;

&lt;p&gt;``` ruby Atribuição
ponto.x, ponto.y = 1, 2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Os lvalues ​​nesta expressão não são variáveis, são atributos.

Atribuição a uma variável funciona como seria de se esperar: a variável é simplesmente definida como o valor especificado. Ruby não tem nenhuma sintaxe para declarar explicitamente uma variável: variáveis ​​simplesmente vir à existência quando são atribuídas. Assim, uma  expressão simples como X poderia se referir a uma variável local chamada x ou um método chamado x. Para resolver essa ambigüidade, Ruby trata de um identificador como uma variável local se tem visto qualquer trabalho anterior para a variável. Ele faz isso com uma atribuição nunca foi executada. O código a seguir demonstra isso:

```ruby Atribuição
class Ambiguous  
  def x; 1; end # Um método chamado &amp;quot;x&amp;quot;. Sempre retorna 1  

  def teste    
    puts x # Nenhuma variável foi visto, refere-se ao método acima: imprime 1    

    # A linha abaixo não é avaliada, por causa da cláusula &amp;quot;if falsa&amp;quot;.
    # Mas o analisador vê e trata x como uma variável para o resto do método.    
    x = 0 if false

    puts x # x é uma variável, mas nunca foi atribuído: irá imprimir nil

    x = 2 # Esta atribuição não é avaliada
    puts x # Então agora esta linha imprime 2  
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Atribuindo a Constantes&lt;/h5&gt;

&lt;p&gt;Constantes são diferentes das variáveis ​​de uma forma óbvia: seus valores são destinados a permanecer constante durante a execução de um programa. Portanto, existem algumas regras especiais para a atribuição de constantes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* Atribuição a uma constante que já existe, faz com o Ruby emita um aviso. O Ruby executa a tarefa,
no entanto, que significa que as constantes não são realmente constante.

* Atribuição a constantes não é permitido dentro do corpo de um método. Ruby assume que os métodos
destinados a ser invocados mais de uma vez, se você poderia atribuir a uma constante em um método,
que método ira emitir alertas a cada requisição após a primeira.  Então, isso simplesmente não é
permitido.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ao contrário das variáveis, as constantes não vem a existir até que o &lt;code&gt;Intérprete Ruby&lt;/code&gt; realmente executa a expressão de atribuição. A expressão não avaliada abaixo, não cria uma constante:&lt;/p&gt;

&lt;p&gt;```ruby Atribuiçao de Constante
N = 100 if false&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Note-se que isto significa que uma constante nunca está em um estado de inicialização. Se uma constante existe, então ele tem um valor atribuído a ela. A constante só terá valor se o valor realmente for `nil`.



&amp;lt;h5&amp;gt;Atribuindo a Atributos e elementos de Array&amp;lt;/h5&amp;gt;

Atribuição a um atributo ou um elemento de um `Array` é na verdade uma abreviação do Ruby para a invocação método. Suponha que um objeto tem um método chamado `m=:`, o nome do método tem um sinal de igual como seu último caractere. Em seguida, `o.m` pode ser usado como um lvalue em uma expressão de atribuição. Suponha, além disso, que o valor v é atribuído:

```ruby Atribuição
o.m = v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O interpretador Ruby converte essa tarefa para a seguinte invocação de método:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
o.m=(v) # Se omitir os parênteses e adicionar um espaço, isso parece tarefa!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Isto é, ele passa o valor v para o método `m=`. Esse método pode fazer o que quiser com o valor. Normalmente, ele irá verificar que o valor é de desejado tipo e dentro da gama desejada, e, em seguida, armazená-lo em uma variável de instância do objeto. Métodos como `m=` são geralmente acompanhados de um método `m`, que simplesmente retorna o valor mais recentemente passado para `m=`. Alguns dizem que `m=` é um método setter e `m` é um método getter. Quando um objeto tem esse par de métodos, dizemos que ele tem um atributo `m`. Atributos são às vezes chamado de &amp;quot;Propriedades&amp;quot; em outras línguas.

Atribuindo valores aos elementos de um `Array` também é feito pelo método de invocação. Se um objeto define um método chamado `[]=` (nome do método é apenas esses três caracteres de pontuação) que espera dois argumentos, então na expressão o `[x] = y` é realmente executado como:

```ruby Atribuição
o.[]= (x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se um objeto tem um método &lt;code&gt;[]=&lt;/code&gt; que espera três argumentos, então ele pode ser indexado com dois valores entre os colchetes. As dois seguintes expressões são equivalentes neste caso:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição
o[x, y] = z
o.[] = (x, y, z)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;h5&amp;gt;Atribuição Abreviada&amp;lt;/h5&amp;gt;

Atribuição Abreviada é uma forma de atribuição que combina atribuição com alguns outras operações. Ele é usado mais comumente para incrementar variáveis:

```ruby Atribuição Abreviada
x += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O &lt;code&gt;+=&lt;/code&gt;, não é um operador real de Ruby, e a expressão acima é simplesmente uma abreviatura para:&lt;/p&gt;

&lt;p&gt;```ruby Atribuição Abreviada
x = x + 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Atribuição Abreviada não pode ser combinado com paralelo de atribuição: ela só funciona quando há um único lvalue à esquerda e um único valor do lado direito. Ela não deve ser usado quando o lvalue é uma constante, porque ele vai reatribuir a constante e causar um aviso. Atribuição abreviada pode, contudo, ser utilizado quando o lvalue é um atributo. As duas expressões a seguir são equivalentes:

```ruby Atribuição Abreviada
o.m += 1
o.m=(o.m()+1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Atribuição abreviada funciona até mesmo quando o lvalue é um elemento de um &lt;code&gt;array&lt;/code&gt;. Estas duas expressões são equivalente:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Atribuição Abreviada
o[x] -= 2
o.[]=(x, o.[](x) - 2)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Observe que esse código usa &lt;code&gt;-=&lt;/code&gt; em vez de &lt;code&gt;+=&lt;/code&gt;. Como você poderia esperar, o &lt;code&gt;-=&lt;/code&gt; é pseudooperator que subtrai seu rvalue a partir do seu lvalue.&lt;/p&gt;

&lt;p&gt;Além &lt;code&gt;+=&lt;/code&gt; e &lt;code&gt;-=&lt;/code&gt;, há outros 11 pseudooperators que podem ser usados ​​para atribuição abreviada. Eles são listados abaixo. Note-se que estes não são verdadeiros operadores próprios, eles são simplesmente uma abreviação para expressões que usam outros operadores. Muitos desses outros operadores são definidos como métodos. Se uma classe define um método chamado &lt;code&gt;+&lt;/code&gt;, por exemplo, em seguida, que as alterações do sentido da Atribuição abreviada com &lt;code&gt;+=&lt;/code&gt; para todas as instâncias dessa classe.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Atribuição                          Expansão
x += y                              x = x + y
x -= y                              x = x - y
x *= y                              x = x * y
x /= y                              x = x / y
x %= y                              x = x % y
x **= y                             x = x ** y
x &amp;amp;&amp;amp;= y                             x = x &amp;amp;&amp;amp; y
x ||= y                             x = x || y
x &amp;amp;= y                              x = x &amp;amp; y
x |= y                              x = x | y
x ^= y                              x = x ^ y
x &amp;lt;&amp;lt;= y                             x = x &amp;lt;&amp;lt; y
x &amp;gt;&amp;gt;= y                             x = x &amp;gt;&amp;gt; y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É isso aí amigos&amp;hellip; até o proximo post!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>invocacoes de metodo</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/02/invocacoes-de-metodo/</link>
      <pubDate>Sat, 02 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/02/invocacoes-de-metodo/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas&lt;/p&gt;

&lt;h1&gt;Invocações de método&lt;/h1&gt;

&lt;p&gt;Uma expressão de invocação de método tem quatro partes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Uma expressão arbitrária cujo valor é o objeto no qual o método é chamado. Esta expressão é seguido por . ou :: para separá-lo a partir
do nome do método que se segue. A expressão e o separador são opcionais; se omitido, o método é invocada em si mesmo.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;O nome do método a ser invocado. Este é o único pedaço exigido de uma expressão chamada de método.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Valores com o argumento passado para o método. A lista de argumentos podem ser colocados entre parênteses, mas estes são geralmente
opcionais. Se há mais de um argumento, eles são separados uns dos outros com vírgulas. O número e tipo de argumentos necessários
dependem da definição do método. Alguns métodos podem ser chamodos sem argumentos.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Um bloco opcional de código delimitado por chaves ou por um par &lt;code&gt;do/end&lt;/code&gt;. O método pode invocar esse código usando a palavra-chave de
&lt;code&gt;yield&lt;/code&gt;. Esta capacidade de associar código arbitrário com qualquer invocação de método é a base para métodos poderosos em Ruby.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Um nome do método é normalmente separado do objeto sobre o qual é chamado com um &lt;code&gt;..&lt;/code&gt;, e com o &lt;code&gt;::&lt;/code&gt;, que também é permitido, mas é raramente
usado porque pode fazer invocações de método parecem mais com referênciar constantes expressões.&lt;/p&gt;

&lt;p&gt;Quando o interpretador Ruby tem o nome de um método e um objeto em que deve ser invocado, ele encontra a definição adequada do método
chamado usando um processo conhecido como &amp;ldquo;método de pesquisa&amp;rdquo; ou &amp;ldquo;resolução de nome do método.&amp;rdquo; Os detalhes não são importantes aqui,
mas eles são explicados completamente no método de pesquisa.&lt;/p&gt;

&lt;p&gt;O valor de uma invocação expressão de método é o valor da expressão avaliada pelo último método no corpo do código. Aqui, no entanto, são
alguns exemplos de invocações de método:&lt;/p&gt;

&lt;p&gt;```ruby Ruby
puts &amp;ldquo;Olá mundo&amp;rdquo; # &amp;ldquo;puts&amp;rdquo; invocado em auto, com uma seqüência de arg
Math.sqrt(2) # &amp;ldquo;sqrt&amp;rdquo; invocado em Matemática objeto com uma arg
message.length # &amp;ldquo;comprimento&amp;rdquo; invocado em mensagem objeto; não args
a.each{|x| p x} # &amp;ldquo;cada&amp;rdquo; chamado em um objeto, com um bloco associado&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Um dos exemplos do método de invocação mostradas anteriormente foi &amp;lt;code&amp;gt;message.length&amp;lt;/code&amp;gt;. Você pode ser tentado a pensar-lo como uma variável
de expressão de referência, avaliando para o valor do comprimento da variável do objeto mensage. Este não é o caso, no entanto, Ruby tem
um modelo de programação muito orientada a objetos: objetos em Ruby podem encapsular qualquer número de variáveis ​​de instância interna,
mas expõem métodos apenas para o mundo exterior. Como o método &amp;lt;code&amp;gt;length&amp;lt;/code&amp;gt; não espera argumentos e é chamado sem os parênteses opcionais,
parece que referência uma variável. Na verdade, isso é intencional. Métodos como estes são chamados para atribuir métodos de acesso, e
dizemos que o objeto da &amp;lt;code&amp;gt;mensage&amp;lt;/code&amp;gt; tem um atributo de &amp;lt;code&amp;gt;lenght&amp;lt;/code&amp;gt;. Como veremos, é possível que o objeto de &amp;lt;code&amp;gt;mensage&amp;lt;/code&amp;gt;
para definir um método chamado &amp;lt;code&amp;gt;length=&amp;lt;/code&amp;gt;. Se este método espera um único argumento, então é um método setter do atributo e
Ruby invoca em resposta a atribuição. Se um tal método é definido, então estas duas linhas de código seria tanto chamar o mesmo método:

```ruby Length
message.length=(3) # invocação do método tradicional
message.length = 3 # invocação Método como a atribuição
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora, considere a seguinte linha de código, assumindo que uma variável contém um &lt;code&gt;Array&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;```ruby Array
a[0]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Você pode pensar novamente que este é um tipo especial de variável de referência, onde a variável em questão é na verdade um elemento do
&amp;lt;code&amp;gt;Array&amp;lt;/code&amp;gt;. Novamente, no entanto, esta é invocação do método. O intérprete Ruby converte o acesso ao &amp;lt;code&amp;gt;Array&amp;lt;/code&amp;gt; para isso:

```ruby Array
a.[](0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O acesso ao &lt;code&gt;Array&lt;/code&gt; torna-se uma invocação do método chamado &lt;code&gt;[]&lt;/code&gt;, com o índice do &lt;code&gt;Array&lt;/code&gt; como seu
argumento. Esta sintaxe de acesso de &lt;code&gt;Array&lt;/code&gt; não se limita a &lt;code&gt;Arrays&lt;/code&gt;. Qualquer objeto é permitido para definir um
método chamado &lt;code&gt;[]&lt;/code&gt;. Quando o objeto é &amp;ldquo;indexado&amp;rdquo;, com o indix entre parênteses, os valores dentro dos parênteses será passado
para o método. Se o método &lt;code&gt;[]&lt;/code&gt; é escrito para esperar três argumentos, então você deve colocar três expressões separados por
vírgula dentro dos colchetes.&lt;/p&gt;

&lt;p&gt;Atribuição de &lt;code&gt;Arrays&lt;/code&gt; também é feito através de invocação de método. Se o objeto o define um método chamado &lt;code&gt;[]=&lt;/code&gt;, então a expressão &lt;code&gt;o[x] = y&lt;/code&gt; torna-se &lt;code&gt;o.[] = (x, y)&lt;/code&gt;, e a expressão &lt;code&gt;o[x, y] = z&lt;/code&gt; se torna &lt;code&gt;o.[] = (x , y, z)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Muitos operadores do Ruby são definidos como métodos, e expressões como &lt;code&gt;x + y&lt;/code&gt; são avaliados como &lt;code&gt;x.+(y)&lt;/code&gt;, onde o
nome de método é &lt;code&gt;+&lt;/code&gt;. O fato de que muitos dos operadores do Ruby são definidos como métodos que significa você pode redefinir
esses operadores na sua próprias classes.&lt;/p&gt;

&lt;p&gt;Agora, vamos considerar esta expressão muito simples:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Ruby
x
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Se uma variável x nomeada existe (Isto é, se o interpretador Ruby tem visto uma atribuição a x), então esta é uma variável de referência.
Se nenhuma variável existe, então esta é uma invocação do método x, sem argumentos.&lt;/p&gt;

&lt;p&gt;A palavra &lt;code&gt;super&lt;/code&gt; em Ruby é um tipo especial de invocação de método. Esta palavra é usada ao criar uma subclasse de outra
classe. Por si só, &lt;code&gt;super&lt;/code&gt; passa os argumentos do método corrente para o método com o mesmo nome na superclasse. Ele também
pode ser usado como se fosse realmente o nome de um método e pode ser seguido por uma lista de argumentos arbitrários. A palavra-chave
&lt;code&gt;super&lt;/code&gt; é abordada em detalhes no Aumentando Comportamento por encadeamento.&lt;/p&gt;

&lt;p&gt;Até a Proxima&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>variaveis nao inicializadas</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/02/variaveis-nao-inicializadas/</link>
      <pubDate>Sat, 02 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/02/variaveis-nao-inicializadas/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas&lt;/p&gt;

&lt;h1&gt;Variáveis ​​não inicializadas&lt;/h1&gt;

&lt;p&gt;Em geral, você deve sempre atribuir um valor para, ou inicializar as variáveis ​​antes de usá-las em expressões. Em algumas circunstâncias,
no entanto, Ruby lhe permitirá utilizar variáveis ​​que ainda não foram inicializadas. As regras são diferentes para diferentes tipos de variáveis:&lt;/p&gt;

&lt;p&gt;&lt;h4&gt;Variáveis ​​de classe&lt;/h4&gt;
    Variáveis ​​de classe deve sempre ter um valor atribuído a elas antes que serem utilizadas. Ruby levanta uma NameError se
    referir a uma variável de classe à qual nenhum valor foi atribuído.&lt;/p&gt;

&lt;p&gt;&lt;h4&gt;Variáveis ​​de instância&lt;/h4&gt;
    Se você se referir a uma variável de instância não inicializada, Ruby retorna nil. Considera-se má programação de
    contar com esse comportamento, no entanto. Ruby vai emitir um aviso sobre a variável não inicializada se você executá-la
    com a opção -w.&lt;/p&gt;

&lt;p&gt;&lt;h4&gt;As variáveis ​​globais&lt;/h4&gt;
    Variáveis ​​globais não inicializadas são como o exemplo de variáveis não inicializadas: elas igualam a nil, mas mostra
    um aviso quando o Ruby é executado com o flag do -w.&lt;/p&gt;

&lt;p&gt;&lt;h4&gt;As variáveis ​​locais&lt;/h4&gt;
    Este caso é mais complicado que os outros, porque variáveis locais ​​não têm um caractere de pontuação como um prefixo.
    Este significa que variáveis ​​locais referênciam olhando apenas como uma invocação de método de expressões. Se o
    interpretador Ruby tem visto uma atribuição de uma variável local, ele sabe que é uma variável e não um método,
    e pode retornar o valor da variável. Se não tiver havido nenhuma atribuição, então o Ruby trata a expressão como uma
    invocação de método. Se nenhum método com esse nome existe, Ruby levanta um NameError.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Em geral, portanto, a tentativa de usar uma variável local antes de ter sido inicializada resulta em um erro. Existe
uma peculiaridade, uma variável passa a existir quando o interpretador Ruby vê uma expressão de atribuição para essa
variável. Este é o caso, mesmo se essa atribuição não é realmente executada. A variável que existe, mas não foi
atribuído um valor, é dado o valor nulo como padrão. Por exemplo:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ruby Variaveis
a = 0.0 if false # atribuição Isso nunca é executado
puts a # Imprime nulo: a variável existe mas não é atribuída
puts b # NameError: nenhuma variável ou método chamado existe b
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html&#34;&gt;Variaveis Ruby 1.9.2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Até a próxima.. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>variaveis de referencia</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/01/variaveis-de-referencia/</link>
      <pubDate>Fri, 01 Jun 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/06/01/variaveis-de-referencia/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Variáveis de Referência&lt;/p&gt;

&lt;h1&gt;Variáveis de Referência&lt;/h1&gt;

&lt;p&gt;Uma variável é simplesmente um nome para um valor. As variáveis ​​são criadas e os valores que lhes são atribuídos por expressões
de atribuição. Quando o nome de uma variável aparece num programa em qualquer lugar que não seja o lado esquerdo de uma atribuição, é uma
variável de referência à expressão e avaliado como o valor da variável:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Referência
one = 1.0 # Esta é uma atribuição de expressão
one # Essa referência de expressão da variável, que imprimi 1.0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Existem quatro tipos de variáveis ​​em Ruby, e regras &lt;a href=&#34;http://pt.wikipedia.org/wiki/Item_lexical&#34;&gt;lexicais&lt;/a&gt; para governar seus nomes. Variáveis que começam com $ são variáveis ​​globais, visível ao longo de um programa Ruby. Variáveis ​​que começam com @ e @@ são
variáveis ​​de instância e variáveis ​​de classe, usado em programação orientada a objeto. E as variáveis ​​cujos nomes começam com um sublinhado
ou uma letra minúscula são variáveis ​​locais, definidas apenas dentro do atual método ou bloco.&lt;/p&gt;

&lt;p&gt;Variáveis ​​sempre são simples, nomes não qualificados. Se um . ou :: aparece em uma expressão, em seguida, que a expressão é ou um
uma referência a uma constante ou uma invocação de método. Por exemplo, Math::PI é uma referência a uma constante, e a expressão
item.preco é uma invocação do método chamado preco (preço) sobre o valor realizado pela variável item.&lt;/p&gt;

&lt;p&gt;O interpretador Ruby predefine um número de variáveis ​​globais quando ele é iniciado.&lt;/p&gt;

&lt;p&gt;Até a próxima.. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>literais e palavras chaves literais</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/05/27/literais-e-palavras-chaves-literais/</link>
      <pubDate>Sun, 27 May 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/05/27/literais-e-palavras-chaves-literais/</guid>
      <description>&lt;p&gt;Hoje vamos continuar falando de &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/&#34;&gt;Ruby&lt;/a&gt;, é hora de nos aprofundar falando um pouco de Literais e Plavras-chaves literais&lt;/p&gt;

&lt;h1&gt;Literais e Plavras-chaves literais&lt;/h1&gt;

&lt;p&gt;Literais são valores como 1.0, &amp;ldquo;Hello world&amp;rdquo;, e [] que são incorporados diretamente em seu texto do programa.&lt;/p&gt;

&lt;p&gt;É interessante notar que muitos literais, tais como números, são as principais expressões - as expressões mais simples possíveis não
compostas de expressões simples. Literais, tais como Array e literais de hash e strings duplas citadas que usam interpolação, incluem
sub-expressões e são, portanto, expressões não primárias.&lt;/p&gt;

&lt;p&gt;Determinadas palavras-chave em Ruby são expressões primárias e podem ser considerados palavras-chave literais ou formas especializadas
de referência da variável:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nil            -&amp;gt;   Avalia o valor nulo, de NilClass classe.
true           -&amp;gt;   Avalia-se à instância singleton da Classe TrueClass, que um objeto representa o valor booleano
                    verdadeiro.
false          -&amp;gt;   Avalia-se à instância singleton da Classe FalseClass, que um objeto representa os valores booleanos
                    falsos.
self           -&amp;gt;   Auto avalia o objeto atual.
__FILE__       -&amp;gt;   Avalia a uma string que nomeia o arquivo que o Ruby Intérprete (IRB) está em execução. Isto pode ser
                    útil em erro de mensagens.
__LINE__       -&amp;gt;   Avalia como um inteiro que especifica o número da linha dentro da linha do código atual do __FILE__.
__ENCODING__   -&amp;gt;   Avalia a um objeto Encoding que especifica a codificação do arquivo atual. (Ruby 1.9 apenas.)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É isso ai galera, até o proximo post.. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>um pouco de array no ruby</title>
      <link>https://limitless-eyrie-46143.herokuapp.com/post/2012/05/07/um-pouco-de-array-no-ruby/</link>
      <pubDate>Mon, 07 May 2012 00:00:00 UTC</pubDate>
      
      <guid>https://limitless-eyrie-46143.herokuapp.com/post/2012/05/07/um-pouco-de-array-no-ruby/</guid>
      <description>&lt;p&gt;Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language&lt;/p&gt;

&lt;p&gt;Um Array é uma seqüência de valores que permite que os valores serem acessados por sua posição, ou índice, na seqüência. Em Ruby, o primeiro valor em um array tem índice 0. Os métodos size e length, retornam o número de elementos em um Array. O último
elemento do Array é no índice de size-1. Valores de índice negativo contar a partir do
final do Array, de modo que o último elemento de uma Array também pode ser acessado
com um índice de -1. O segundo ao último tem um índice de -2,
e assim por diante. Se você tentar ler um elemento além do final de uma Array
(Com um index &amp;gt;= size), ou antes
o início de um Array (com um index &amp;lt; size), Ruby simplesmente retorna nil e não lançará uma exceção.&lt;/p&gt;

&lt;p&gt;Arrays de Ruby não são tipados e mutáveis. Os elementos de um Array
não precisam de ser todos da mesma classe, e eles podem ser alterados em qualquer momento.
Além disso, os Arrays são dinamicamente redimensionáveis, você pode acrescentar elementos
a eles e crescer conforme necessário. Se você atribuir um valor a um elemento
além do final do Array, a Array é automaticamente prorrogado com
elementos nil. (É um erro, No entanto, para atribuir um valor para um elemento antes do início de um
Array.)&lt;/p&gt;

&lt;p&gt;Uma Array literal é uma lista separada por vírgulas de valores, dentro de
parênteses:&lt;/p&gt;

&lt;p&gt;``` ruby Arrays Literal
[1, 2, 3] # Uma Array que contém três objetos Fixnum
[-10 &amp;hellip; 0, 0 .. 10,] # Uma Array de duas faixas; vírgulas extras são permitidos
[[1,2], [3,4], [5]] # Uma Array de Arrayes aninhadas
[X + y, xy, x * y] # array os elementos podem ser expressões arbitrárias
[] # O array vazio tem o tamanho 0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Ruby inclui uma sintaxe especial, no caso para expressar literais de Array
cujos elementos são seqüências curtas sem espaços:

``` ruby Arrays
palavras = %w[este é um teste] # O mesmo que: [&#39;este&#39;, &#39;é&#39;, &#39;um&#39;, &#39;teste&#39;]
aberto = %w| ( [ { &amp;lt; | # O mesmo que: [&#39;(&#39;, &#39;[&#39;, &#39;{&#39;, &#39;&amp;lt;&#39;]
branco = %W(\s \t \r \n) # O mesmo que: [&amp;quot;\ s&amp;quot;, &amp;quot;\ t&amp;quot;, &amp;quot;\ r&amp;quot;, &amp;quot;\ n&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;%w e %W introduzir uma Array literal, bem como %q e %Q introduzir uma string literal. Em
particular, as regras delimitadores para %w e %W são as mesmos que para %q e %Q. Dentro dos delimitadores, sem aspas
são necessários em torno das cadeias de elementos do array, e sem vírgulas são
requerido entre os elementos. Elementos do Array são delimitados por espaço em branco.&lt;/p&gt;

&lt;p&gt;Você também pode criar Arrays com o construtor Array.new, e isso proporciona
opções de programação inicializando os elementos de Array:&lt;/p&gt;

&lt;p&gt;``` ruby Initiallize Array
vazio = Array.new # []: retorna um novo array vazio
nils = Array.new(3) # [nil, nil, nil]: nova Array com 3 elementos nulos
zeros = Array.new(4, 0) # [0, 0, 0, 0]: nova Array com 4 elementos 0
cópia = Array.new(nils) # Faça uma nova cópia de uma Array existente
count = Array.new(3) {| i | i +1} # [1,2,3]: 3 elementos calculado a partir do índice&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Para obter o valor de um elemento do Array, use um único número inteiro
entre colchetes:

``` ruby Valores com Array
a = [0, 1, 4, 9, 16] # O Array mantém os quadrados dos índices
a[0] # primeiro elemento é 0
a[-1] # O ultimo elemento é de 16
a[-2] # segundo ao último elemento é 9
a[a.size-1] # Outra forma de consultar o último elemento
a[-a.size] # Outra forma de consultar o primeiro elemento
a[8] # Consultando além do fim retorna nil
a[-8] # Consultando antes do início retorna nil, também
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Todas as expressões acima, exceto para a última, pode também ser
utilizado no lado esquerdo de uma atribuição:&lt;/p&gt;

&lt;p&gt;``` ruby Arrays
a[0] = &amp;ldquo;zero&amp;rdquo; # a é [&amp;ldquo;zero&amp;rdquo;, 1, 4, 9, 16]
a[-1] = 1..16 # a é [&amp;ldquo;zero&amp;rdquo;, 1, 4, 9, 1 .. 16]
a[8] = 64 # a é [&amp;ldquo;zero&amp;rdquo;, 1, 4, 9, 1 .. 16, nil, nil, nil, 64]
a[-10] = 100 # erro: não é possível atribuir antes do início de um array&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Como strings, Arrayes também podem ser indexados com dois números inteiros que
representam um índice de partida e um número de elementos, ou um objeto de intervalo. Em qualquer caso, a expressão
retorna o sub-array especificado:

``` ruby Array
a = (&#39;a&#39;..&#39;e&#39;).to_a # Faixa convertido para [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
a[0,0] # []: este subarray tem zero elementos
a[1,1] # [&#39;b&#39;]: uma Array de um elemento
a[-2,2] # [&#39;d&#39;, &#39;e&#39;]: os últimos dois elementos do array
a[0..2] # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]: os primeiros três elementos
a[-2 .. -1] # [&#39;d&#39;, &#39;e&#39;]: os últimos dois elementos do array
a [0 ... -1] # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]: a totalidade, mas o último elemento
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando utilizado no lado esquerdo de uma atribuição, um sub-array pode ser
substituído pelos elementos do Array do lado direito. Esta básica
operação funciona para inserções e exclusões, bem como:&lt;/p&gt;

&lt;p&gt;```ruby Arrays
a[0,2] = [&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;] # se torna [&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;c&amp;rsquo;, &amp;rsquo;d&amp;rsquo;, &amp;lsquo;e&amp;rsquo;]
a[2 &amp;hellip; 5] = [&amp;lsquo;C&amp;rsquo;, &amp;rsquo;D&amp;rsquo;, &amp;lsquo;E&amp;rsquo;] # se torna [&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;, &amp;rsquo;D&amp;rsquo;, &amp;lsquo;E&amp;rsquo;]
a[0,0] = [1,2,3] # Inserir elementos no início de a
a[0 .. 2] = [] # Excluir os elementos
a[-1,1] = [&amp;lsquo;Z&amp;rsquo;] # Substitua último elemento com outro
a[-1,1] = &amp;lsquo;Z&amp;rsquo; # Para os elementos individuais, a Array é opcional
a[-2,2] = nil # Excluir últimos 2 elementos em 1,8; substituir com nil em 1,9&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Além disso para o operador colchete para indexar um Array,
a classe Array define uma série de outros operadores úteis. Use + para
concatenar dois Arrays:

```ruby Concatenar Arrays
a = [1, 2, 3] + [4, 5] # [1, 2, 3, 4, 5]
a = a + [[6, 7, 8]] # [1, 2, 3, 4, 5, [6, 7, 8]]
a = a + 9 # erro: lado direito deve ser um array
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O operador + cria um novo Array que contém os elementos de ambos os seus operandos. Use &amp;lt;&amp;lt; para acrescentar um elemento para o final de um
Array existente, e usar a concat anexar os elementos de um array:&lt;/p&gt;

&lt;p&gt;``` ruby Array + e concat
a = [] # Comece com uma Array vazia
a &amp;lt;&amp;lt; 1 # a é [1]
a &amp;lt;&amp;lt; 2 &amp;lt;&amp;lt; 3 # a é [1, 2, 3]
a &amp;lt;&amp;lt; [4,5,6] # a é [1, 2, 3, [4, 5, 6]]
a.concat [7,8] # a é [1, 2, 3, [4, 5, 6], 7, 8]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
O operador - subtrai um Array do outro. Começa por fazer uma cópia de sua Array da esquerda,
e, em seguida, remove todos os elementos de que a cópia se que apareçam em qualquer
a Array do lado direito:

``` ruby Array -
[&#39;A&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] - [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;] # [&#39;A&#39;, &#39;a&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como a classe String, Array também usa o operador de multiplicação
para a repetição:&lt;/p&gt;

&lt;p&gt;```ruby Array *
a = [0] * 8 # [0, 0, 0, 0, 0, 0, 0, 0]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
A classe Array contem tambem os Operadores booleanos (| , &amp;amp;) e usa-los para a união e
interseção. | Concatena seu argumentos e, em seguida, remove todos os elementos repetidos no resultado.
&amp;amp; retorna uma Array que contém elementos que aparecem em ambas as Arrayes de operando. A Array retornada
não contém elementos duplicados:

``` ruby Array
a = [1, 1, 2, 2, 3, 3, 4]
b = [5, 5, 4, 4, 3, 3, 2]
a | b # [1, 2, 3, 4, 5]: duplicatas são removidas
b | a # [5, 4, 3, 2, 1]: elementos são os mesmos, mas a ordem é diferente
a &amp;amp; b # [2, 3, 4]
b &amp;amp; a # [4, 3, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note-se que estes operadores não são transitivos: a | b não é o mesmo que b | a, por exemplo. Se você ignorar o ordenamento
dos elementos, no entanto, e considerar os Arrays para ser ordenado os conjuntos,
então estes operadores fazem mais sentido. Note também que o algoritmo
que a união e intersecção são realizados não é especificado, e não
existem garantias sobre a ordem dos elementos no retornou dos
Arrays.&lt;/p&gt;

&lt;p&gt;A classe Array define um bom número de alguns métodos úteis. O único que vamos discutir aqui é o iterador each, usada para loop através ds
elementos de um Array:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby Array each
a = (&#39;A&#39; .. &#39;Z&#39;).to_a # Comece com uma série de cartas
a.each {| x | print x} # Imprimir o alfabeto, uma letra de cada vez
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Outros métodos do Array você pode deseja procurar,  incluindo: clear,
compact!, delete_if, each_index, empty?, fill, flatten!, include?, index, join, pop,
push, reverse, reverse_each, rindex, shift, sort, sort!, uniq!, e unshift.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruby-doc.org/core-1.9.2/Array.html&#34;&gt;www.ruby-doc.org/core-1.9.2/Array.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Até a proxima amigos&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
